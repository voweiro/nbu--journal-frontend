"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/utils/api.ts":
/*!**************************!*\
  !*** ./src/utils/api.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authAPI: function() { return /* binding */ authAPI; },\n/* harmony export */   journalAPI: function() { return /* binding */ journalAPI; },\n/* harmony export */   reviewAPI: function() { return /* binding */ reviewAPI; },\n/* harmony export */   userAPI: function() { return /* binding */ userAPI; }\n/* harmony export */ });\n/* harmony import */ var _corsAwareApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./corsAwareApi */ \"./src/utils/corsAwareApi.js\");\n\n// Use the CORS-aware API client instead of creating a new one\nconst api = _corsAwareApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n// Auth API\nconst authAPI = {\n    register: async (formData)=>{\n        const response = await api.post(\"/auth/register\", formData, {\n            headers: {\n                \"Content-Type\": \"multipart/form-data\"\n            }\n        });\n        return response.data;\n    },\n    verifyEmail: async (email, otp)=>{\n        const response = await api.post(\"/auth/verify-email\", {\n            email,\n            otp\n        });\n        return response.data;\n    },\n    resendOTP: async (email)=>{\n        const response = await api.post(\"/auth/resend-otp\", {\n            email\n        });\n        return response.data;\n    },\n    login: async (email, password)=>{\n        const response = await api.post(\"/auth/login\", {\n            email,\n            password\n        });\n        return response.data;\n    },\n    getProfile: async ()=>{\n        const response = await api.get(\"/auth/profile\");\n        return response.data;\n    },\n    changePassword: async (currentPassword, newPassword)=>{\n        const response = await api.put(\"/auth/change-password\", {\n            currentPassword,\n            newPassword\n        });\n        return response.data;\n    },\n    resetPassword: async (userId, newPassword)=>{\n        const response = await api.put(\"/auth/reset-password\", {\n            userId,\n            newPassword\n        });\n        return response.data;\n    },\n    forgotPassword: async (email)=>{\n        const response = await api.post(\"/auth/forgot-password\", {\n            email\n        });\n        return response.data;\n    },\n    verifyResetToken: async (email, token)=>{\n        const response = await api.post(\"/auth/verify-reset-token\", {\n            email,\n            token\n        });\n        return response.data;\n    },\n    resetPasswordWithToken: async (email, token, password)=>{\n        const response = await api.post(\"/auth/reset-password-with-token\", {\n            email,\n            token,\n            password\n        });\n        return response.data;\n    }\n};\n// User API\nconst userAPI = {\n    getAllUsers: async (role)=>{\n        const response = await api.get(\"/users\", {\n            params: {\n                role\n            }\n        });\n        return response.data;\n    },\n    getUserById: async (id)=>{\n        const response = await api.get(\"/users/\".concat(id));\n        return response.data;\n    },\n    createUser: async (userData)=>{\n        const response = await api.post(\"/users\", userData);\n        return response.data;\n    },\n    updateUser: async (id, formData)=>{\n        const response = await api.put(\"/users/\".concat(id), formData, {\n            headers: {\n                \"Content-Type\": \"multipart/form-data\"\n            }\n        });\n        return response.data;\n    },\n    deleteUser: async (id)=>{\n        const response = await api.delete(\"/users/\".concat(id));\n        return response.data;\n    },\n    resetPassword: async (userId, newPassword)=>{\n        const response = await api.post(\"/auth/reset-password\", {\n            userId,\n            newPassword\n        });\n        return response.data;\n    }\n};\n// Journal API\nconst journalAPI = {\n    getPublishedJournals: async function() {\n        let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        // Use params object instead of manually constructing URL\n        const response = await api.get(\"/journals/published\", {\n            params: {\n                sort_by: filters.sort_by || \"published_date\",\n                sort_order: filters.sort_order || \"DESC\",\n                search: filters.search || \"\",\n                limit: filters.limit || null,\n                page: filters.page || null,\n                _t: new Date().getTime() // Cache-busting parameter\n            }\n        });\n        console.log(\"API response for published journals:\", response.data);\n        return response.data;\n    },\n    createJournal: async (formData)=>{\n        const response = await api.post(\"/journals\", formData, {\n            headers: {\n                \"Content-Type\": \"multipart/form-data\"\n            }\n        });\n        return response.data;\n    },\n    getAllJournals: async (filters)=>{\n        const response = await api.get(\"/journals\", {\n            params: filters\n        });\n        return response.data;\n    },\n    getJournalById: async (id)=>{\n        try {\n            // First try to get the journal as a published journal (no auth required)\n            const response = await api.get(\"/journals/published/\".concat(id));\n            return response.data;\n        } catch (error) {\n            // If that fails (e.g., journal is not published), fall back to the authenticated route\n            const response = await api.get(\"/journals/\".concat(id));\n            return response.data;\n        }\n    },\n    getAllReviewers: async ()=>{\n        const response = await api.get(\"/journals/reviewers\");\n        return response.data;\n    },\n    assignReviewer: async (journalId, reviewerId)=>{\n        const response = await api.put(\"/journals/\".concat(journalId, \"/assign\"), {\n            reviewer_id: reviewerId\n        });\n        return response.data;\n    },\n    reviewJournal: async (journalId, status, comments)=>{\n        const response = await api.put(\"/journals/\".concat(journalId, \"/review\"), {\n            status,\n            comments\n        });\n        return response.data;\n    },\n    getJournalFile: async (journalId)=>{\n        const response = await api.get(\"/journals/\".concat(journalId, \"/file\"));\n        return response.data;\n    },\n    downloadJournal: async (journalId)=>{\n        try {\n            // First try to get the journal to check if it's published\n            const { journal } = await journalAPI.getJournalById(journalId);\n            // For published journals, try to get file info from the public endpoint\n            let fileInfo;\n            try {\n                // For published journals, we can try the public endpoint first\n                if (journal.status === \"published\") {\n                    // Try to get file info from the public endpoint\n                    const response = await api.get(\"/journals/published/\".concat(journalId, \"/file\"));\n                    fileInfo = response.data;\n                } else {\n                    // For non-published journals, use the authenticated endpoint\n                    fileInfo = await journalAPI.getJournalFile(journalId);\n                }\n            } catch (error) {\n                console.log(\"Could not get file info, proceeding with direct download\", error);\n            }\n            // If we have Google Drive file info with a download URL, use that\n            if (fileInfo && fileInfo.downloadUrl) {\n                console.log(\"Using Google Drive download URL:\", fileInfo.downloadUrl);\n                window.open(fileInfo.downloadUrl, \"_blank\");\n                return;\n            }\n            // If Google Drive info is not available, try direct download\n            console.log(\"Falling back to direct download\");\n            // Create a temporary hidden anchor element\n            const a = document.createElement(\"a\");\n            a.style.display = \"none\";\n            // Use the hardcoded backend URL to avoid any caching issues\n            const apiBaseUrl = BACKEND_URL.replace(\"/api\", \"\");\n            // Use the public route for published journals, otherwise use the authenticated route\n            if (journal.status === \"published\") {\n                a.href = \"\".concat(apiBaseUrl, \"/api/journals/published/\").concat(journalId, \"/download\");\n                // Try alternative path if API base URL doesn't include /api\n                if (!apiBaseUrl.includes(\"/api\")) {\n                    a.href = \"\".concat(apiBaseUrl, \"/journals/published/\").concat(journalId, \"/download\");\n                }\n            } else {\n                // Fallback to the authenticated route\n                const token = localStorage.getItem(\"token\");\n                a.href = \"\".concat(apiBaseUrl, \"/api/journals/\").concat(journalId, \"/download\");\n                // Try alternative path if API base URL doesn't include /api\n                if (!apiBaseUrl.includes(\"/api\")) {\n                    a.href = \"\".concat(apiBaseUrl, \"/journals/\").concat(journalId, \"/download\");\n                }\n                // Add the token as a query parameter\n                if (token) {\n                    a.href += \"?token=\".concat(token);\n                }\n            }\n            console.log(\"Download URL:\", a.href);\n            // Append to body, click, and remove\n            document.body.appendChild(a);\n            a.click();\n            document.body.removeChild(a);\n        } catch (error) {\n            console.error(\"Error downloading journal:\", error);\n        }\n    },\n    deleteJournal: async (journalId)=>{\n        const response = await api.delete(\"/journals/\".concat(journalId));\n        return response.data;\n    },\n    updateJournalStatus: async (journalId, status)=>{\n        const response = await api.put(\"/journals/\".concat(journalId, \"/status\"), {\n            status\n        });\n        return response.data;\n    },\n    publishJournal: async (journalId, publicationNumber)=>{\n        // Use publication_number to match the backend's expected parameter name\n        const response = await api.put(\"/journals/\".concat(journalId, \"/publish\"), {\n            publication_number: publicationNumber\n        });\n        return response.data;\n    },\n    unpublishJournal: async (journalId)=>{\n        const response = await api.put(\"/journals/\".concat(journalId, \"/unpublish\"));\n        return response.data;\n    }\n};\n// Review API\nconst reviewAPI = {\n    getJournalReviews: async (journalId)=>{\n        const response = await api.get(\"/reviews/journal/\".concat(journalId));\n        return response.data;\n    },\n    getAssignedReviews: async ()=>{\n        const response = await api.get(\"/reviews/assigned\");\n        return response.data;\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (api);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUN2QkMsbUJBQW1CLE9BQU9wQztRQUN4QixNQUFNcEQsV0FBVyxNQUFNSixJQUFJZSxHQUFHLENBQUMsb0JBQThCLE9BQVZ5QztRQUNuRCxPQUFPcEQsU0FBU0csSUFBSTtJQUN0QjtJQUVBc0Ysb0JBQW9CO1FBQ2xCLE1BQU16RixXQUFXLE1BQU1KLElBQUllLEdBQUcsQ0FBQztRQUMvQixPQUFPWCxTQUFTRyxJQUFJO0lBQ3RCO0FBQ0YsRUFBRTtBQUVGLCtEQUFlUCxHQUFHQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy9hcGkudHM/Yjk3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBVc2VyLCBKb3VybmFsLCBKb3VybmFsU3RhdHVzLCBKb3VybmFsRmlsdGVycyB9IGZyb20gJ0AvdHlwZXMnO1xuaW1wb3J0IGNvcnNBd2FyZUFwaSBmcm9tICcuL2NvcnNBd2FyZUFwaSc7XG5cbi8vIFVzZSB0aGUgQ09SUy1hd2FyZSBBUEkgY2xpZW50IGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgb25lXG5jb25zdCBhcGkgPSBjb3JzQXdhcmVBcGk7XG5cbi8vIEF1dGggQVBJXG5leHBvcnQgY29uc3QgYXV0aEFQSSA9IHtcbiAgcmVnaXN0ZXI6IGFzeW5jIChmb3JtRGF0YTogRm9ybURhdGEpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvYXV0aC9yZWdpc3RlcicsIGZvcm1EYXRhLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIHZlcmlmeUVtYWlsOiBhc3luYyAoZW1haWw6IHN0cmluZywgb3RwOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvYXV0aC92ZXJpZnktZW1haWwnLCB7IGVtYWlsLCBvdHAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG5cbiAgcmVzZW5kT1RQOiBhc3luYyAoZW1haWw6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9hdXRoL3Jlc2VuZC1vdHAnLCB7IGVtYWlsIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIGxvZ2luOiBhc3luYyAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9hdXRoL2xvZ2luJywgeyBlbWFpbCwgcGFzc3dvcmQgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG5cbiAgZ2V0UHJvZmlsZTogYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL2F1dGgvcHJvZmlsZScpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIGNoYW5nZVBhc3N3b3JkOiBhc3luYyAoY3VycmVudFBhc3N3b3JkOiBzdHJpbmcsIG5ld1Bhc3N3b3JkOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wdXQoJy9hdXRoL2NoYW5nZS1wYXNzd29yZCcsIHtcbiAgICAgIGN1cnJlbnRQYXNzd29yZCxcbiAgICAgIG5ld1Bhc3N3b3JkLFxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIHJlc2V0UGFzc3dvcmQ6IGFzeW5jICh1c2VySWQ6IG51bWJlciwgbmV3UGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnB1dCgnL2F1dGgvcmVzZXQtcGFzc3dvcmQnLCB7XG4gICAgICB1c2VySWQsXG4gICAgICBuZXdQYXNzd29yZCxcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcblxuICBmb3Jnb3RQYXNzd29yZDogYXN5bmMgKGVtYWlsOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvYXV0aC9mb3Jnb3QtcGFzc3dvcmQnLCB7IGVtYWlsIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIHZlcmlmeVJlc2V0VG9rZW46IGFzeW5jIChlbWFpbDogc3RyaW5nLCB0b2tlbjogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdCgnL2F1dGgvdmVyaWZ5LXJlc2V0LXRva2VuJywgeyBlbWFpbCwgdG9rZW4gfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG5cbiAgcmVzZXRQYXNzd29yZFdpdGhUb2tlbjogYXN5bmMgKGVtYWlsOiBzdHJpbmcsIHRva2VuOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvYXV0aC9yZXNldC1wYXNzd29yZC13aXRoLXRva2VuJywgeyBlbWFpbCwgdG9rZW4sIHBhc3N3b3JkIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxufTtcblxuLy8gVXNlciBBUElcbmV4cG9ydCBjb25zdCB1c2VyQVBJID0ge1xuICBnZXRBbGxVc2VyczogYXN5bmMgKHJvbGU/OiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoJy91c2VycycsIHtcbiAgICAgIHBhcmFtczogeyByb2xlIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG5cbiAgZ2V0VXNlckJ5SWQ6IGFzeW5jIChpZDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KGAvdXNlcnMvJHtpZH1gKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcblxuICBjcmVhdGVVc2VyOiBhc3luYyAodXNlckRhdGE6IHtcbiAgICB1c2VybmFtZTogc3RyaW5nO1xuICAgIGVtYWlsOiBzdHJpbmc7XG4gICAgcGFzc3dvcmQ6IHN0cmluZztcbiAgICBmaXJzdF9uYW1lOiBzdHJpbmc7XG4gICAgbGFzdF9uYW1lOiBzdHJpbmc7XG4gICAgcm9sZTogc3RyaW5nO1xuICAgIGRlcGFydG1lbnQ/OiBzdHJpbmc7XG4gIH0pID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvdXNlcnMnLCB1c2VyRGF0YSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG5cbiAgdXBkYXRlVXNlcjogYXN5bmMgKGlkOiBudW1iZXIsIGZvcm1EYXRhOiBGb3JtRGF0YSkgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnB1dChgL3VzZXJzLyR7aWR9YCwgZm9ybURhdGEsIHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJyxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG5cbiAgZGVsZXRlVXNlcjogYXN5bmMgKGlkOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5kZWxldGUoYC91c2Vycy8ke2lkfWApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIHJlc2V0UGFzc3dvcmQ6IGFzeW5jICh1c2VySWQ6IG51bWJlciwgbmV3UGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoYC9hdXRoL3Jlc2V0LXBhc3N3b3JkYCwgeyB1c2VySWQsIG5ld1Bhc3N3b3JkIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxufTtcblxuLy8gSm91cm5hbCBBUElcbmV4cG9ydCBjb25zdCBqb3VybmFsQVBJID0ge1xuICBnZXRQdWJsaXNoZWRKb3VybmFsczogYXN5bmMgKGZpbHRlcnM6IEpvdXJuYWxGaWx0ZXJzID0ge30pID0+IHtcbiAgICAvLyBVc2UgcGFyYW1zIG9iamVjdCBpbnN0ZWFkIG9mIG1hbnVhbGx5IGNvbnN0cnVjdGluZyBVUkxcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoJy9qb3VybmFscy9wdWJsaXNoZWQnLCB7XG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgc29ydF9ieTogZmlsdGVycy5zb3J0X2J5IHx8ICdwdWJsaXNoZWRfZGF0ZScsXG4gICAgICAgIHNvcnRfb3JkZXI6IGZpbHRlcnMuc29ydF9vcmRlciB8fCAnREVTQycsXG4gICAgICAgIHNlYXJjaDogZmlsdGVycy5zZWFyY2ggfHwgJycsXG4gICAgICAgIGxpbWl0OiBmaWx0ZXJzLmxpbWl0IHx8IG51bGwsXG4gICAgICAgIHBhZ2U6IGZpbHRlcnMucGFnZSB8fCBudWxsLFxuICAgICAgICBfdDogbmV3IERhdGUoKS5nZXRUaW1lKCkgLy8gQ2FjaGUtYnVzdGluZyBwYXJhbWV0ZXJcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zb2xlLmxvZygnQVBJIHJlc3BvbnNlIGZvciBwdWJsaXNoZWQgam91cm5hbHM6JywgcmVzcG9uc2UuZGF0YSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG4gIFxuICBjcmVhdGVKb3VybmFsOiBhc3luYyAoZm9ybURhdGE6IEZvcm1EYXRhKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdCgnL2pvdXJuYWxzJywgZm9ybURhdGEsIHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJyxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG5cbiAgZ2V0QWxsSm91cm5hbHM6IGFzeW5jIChmaWx0ZXJzPzogSm91cm5hbEZpbHRlcnMpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoJy9qb3VybmFscycsIHtcbiAgICAgIHBhcmFtczogZmlsdGVycyxcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcblxuICBnZXRKb3VybmFsQnlJZDogYXN5bmMgKGlkOiBudW1iZXIpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gRmlyc3QgdHJ5IHRvIGdldCB0aGUgam91cm5hbCBhcyBhIHB1Ymxpc2hlZCBqb3VybmFsIChubyBhdXRoIHJlcXVpcmVkKVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KGAvam91cm5hbHMvcHVibGlzaGVkLyR7aWR9YCk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSWYgdGhhdCBmYWlscyAoZS5nLiwgam91cm5hbCBpcyBub3QgcHVibGlzaGVkKSwgZmFsbCBiYWNrIHRvIHRoZSBhdXRoZW50aWNhdGVkIHJvdXRlXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoYC9qb3VybmFscy8ke2lkfWApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICB9LFxuXG4gIGdldEFsbFJldmlld2VyczogYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL2pvdXJuYWxzL3Jldmlld2VycycpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIGFzc2lnblJldmlld2VyOiBhc3luYyAoam91cm5hbElkOiBudW1iZXIsIHJldmlld2VySWQ6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnB1dChgL2pvdXJuYWxzLyR7am91cm5hbElkfS9hc3NpZ25gLCB7XG4gICAgICByZXZpZXdlcl9pZDogcmV2aWV3ZXJJZCxcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcblxuICByZXZpZXdKb3VybmFsOiBhc3luYyAoam91cm5hbElkOiBudW1iZXIsIHN0YXR1czogJ2FwcHJvdmVkJyB8ICdyZWplY3RlZCcsIGNvbW1lbnRzOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wdXQoYC9qb3VybmFscy8ke2pvdXJuYWxJZH0vcmV2aWV3YCwge1xuICAgICAgc3RhdHVzLFxuICAgICAgY29tbWVudHMsXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG5cbiAgZ2V0Sm91cm5hbEZpbGU6IGFzeW5jIChqb3VybmFsSWQ6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldChgL2pvdXJuYWxzLyR7am91cm5hbElkfS9maWxlYCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG4gIFxuICBkb3dubG9hZEpvdXJuYWw6IGFzeW5jIChqb3VybmFsSWQ6IG51bWJlcikgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBGaXJzdCB0cnkgdG8gZ2V0IHRoZSBqb3VybmFsIHRvIGNoZWNrIGlmIGl0J3MgcHVibGlzaGVkXG4gICAgICBjb25zdCB7IGpvdXJuYWwgfSA9IGF3YWl0IGpvdXJuYWxBUEkuZ2V0Sm91cm5hbEJ5SWQoam91cm5hbElkKTtcbiAgICAgIFxuICAgICAgLy8gRm9yIHB1Ymxpc2hlZCBqb3VybmFscywgdHJ5IHRvIGdldCBmaWxlIGluZm8gZnJvbSB0aGUgcHVibGljIGVuZHBvaW50XG4gICAgICBsZXQgZmlsZUluZm87XG4gICAgICB0cnkge1xuICAgICAgICAvLyBGb3IgcHVibGlzaGVkIGpvdXJuYWxzLCB3ZSBjYW4gdHJ5IHRoZSBwdWJsaWMgZW5kcG9pbnQgZmlyc3RcbiAgICAgICAgaWYgKGpvdXJuYWwuc3RhdHVzID09PSAncHVibGlzaGVkJykge1xuICAgICAgICAgIC8vIFRyeSB0byBnZXQgZmlsZSBpbmZvIGZyb20gdGhlIHB1YmxpYyBlbmRwb2ludFxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldChgL2pvdXJuYWxzL3B1Ymxpc2hlZC8ke2pvdXJuYWxJZH0vZmlsZWApO1xuICAgICAgICAgIGZpbGVJbmZvID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGb3Igbm9uLXB1Ymxpc2hlZCBqb3VybmFscywgdXNlIHRoZSBhdXRoZW50aWNhdGVkIGVuZHBvaW50XG4gICAgICAgICAgZmlsZUluZm8gPSBhd2FpdCBqb3VybmFsQVBJLmdldEpvdXJuYWxGaWxlKGpvdXJuYWxJZCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDb3VsZCBub3QgZ2V0IGZpbGUgaW5mbywgcHJvY2VlZGluZyB3aXRoIGRpcmVjdCBkb3dubG9hZCcsIGVycm9yKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgd2UgaGF2ZSBHb29nbGUgRHJpdmUgZmlsZSBpbmZvIHdpdGggYSBkb3dubG9hZCBVUkwsIHVzZSB0aGF0XG4gICAgICBpZiAoZmlsZUluZm8gJiYgZmlsZUluZm8uZG93bmxvYWRVcmwpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1VzaW5nIEdvb2dsZSBEcml2ZSBkb3dubG9hZCBVUkw6JywgZmlsZUluZm8uZG93bmxvYWRVcmwpO1xuICAgICAgICB3aW5kb3cub3BlbihmaWxlSW5mby5kb3dubG9hZFVybCwgJ19ibGFuaycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIEdvb2dsZSBEcml2ZSBpbmZvIGlzIG5vdCBhdmFpbGFibGUsIHRyeSBkaXJlY3QgZG93bmxvYWRcbiAgICAgIGNvbnNvbGUubG9nKCdGYWxsaW5nIGJhY2sgdG8gZGlyZWN0IGRvd25sb2FkJyk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBoaWRkZW4gYW5jaG9yIGVsZW1lbnRcbiAgICAgIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICBhLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICBcbiAgICAgIC8vIFVzZSB0aGUgaGFyZGNvZGVkIGJhY2tlbmQgVVJMIHRvIGF2b2lkIGFueSBjYWNoaW5nIGlzc3Vlc1xuICAgICAgY29uc3QgYXBpQmFzZVVybCA9IEJBQ0tFTkRfVVJMLnJlcGxhY2UoJy9hcGknLCAnJyk7XG4gICAgICBcbiAgICAgIC8vIFVzZSB0aGUgcHVibGljIHJvdXRlIGZvciBwdWJsaXNoZWQgam91cm5hbHMsIG90aGVyd2lzZSB1c2UgdGhlIGF1dGhlbnRpY2F0ZWQgcm91dGVcbiAgICAgIGlmIChqb3VybmFsLnN0YXR1cyA9PT0gJ3B1Ymxpc2hlZCcpIHtcbiAgICAgICAgYS5ocmVmID0gYCR7YXBpQmFzZVVybH0vYXBpL2pvdXJuYWxzL3B1Ymxpc2hlZC8ke2pvdXJuYWxJZH0vZG93bmxvYWRgO1xuICAgICAgICAvLyBUcnkgYWx0ZXJuYXRpdmUgcGF0aCBpZiBBUEkgYmFzZSBVUkwgZG9lc24ndCBpbmNsdWRlIC9hcGlcbiAgICAgICAgaWYgKCFhcGlCYXNlVXJsLmluY2x1ZGVzKCcvYXBpJykpIHtcbiAgICAgICAgICBhLmhyZWYgPSBgJHthcGlCYXNlVXJsfS9qb3VybmFscy9wdWJsaXNoZWQvJHtqb3VybmFsSWR9L2Rvd25sb2FkYDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gdGhlIGF1dGhlbnRpY2F0ZWQgcm91dGVcbiAgICAgICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKTtcbiAgICAgICAgYS5ocmVmID0gYCR7YXBpQmFzZVVybH0vYXBpL2pvdXJuYWxzLyR7am91cm5hbElkfS9kb3dubG9hZGA7XG4gICAgICAgIC8vIFRyeSBhbHRlcm5hdGl2ZSBwYXRoIGlmIEFQSSBiYXNlIFVSTCBkb2Vzbid0IGluY2x1ZGUgL2FwaVxuICAgICAgICBpZiAoIWFwaUJhc2VVcmwuaW5jbHVkZXMoJy9hcGknKSkge1xuICAgICAgICAgIGEuaHJlZiA9IGAke2FwaUJhc2VVcmx9L2pvdXJuYWxzLyR7am91cm5hbElkfS9kb3dubG9hZGA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCB0aGUgdG9rZW4gYXMgYSBxdWVyeSBwYXJhbWV0ZXJcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgYS5ocmVmICs9IGA/dG9rZW49JHt0b2tlbn1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdEb3dubG9hZCBVUkw6JywgYS5ocmVmKTtcbiAgICAgIFxuICAgICAgLy8gQXBwZW5kIHRvIGJvZHksIGNsaWNrLCBhbmQgcmVtb3ZlXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpO1xuICAgICAgYS5jbGljaygpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChhKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZG93bmxvYWRpbmcgam91cm5hbDonLCBlcnJvcik7XG4gICAgfVxuICB9LFxuICBcbiAgZGVsZXRlSm91cm5hbDogYXN5bmMgKGpvdXJuYWxJZDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZGVsZXRlKGAvam91cm5hbHMvJHtqb3VybmFsSWR9YCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG4gIFxuICB1cGRhdGVKb3VybmFsU3RhdHVzOiBhc3luYyAoam91cm5hbElkOiBudW1iZXIsIHN0YXR1czogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucHV0KGAvam91cm5hbHMvJHtqb3VybmFsSWR9L3N0YXR1c2AsIHsgc3RhdHVzIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuICBcbiAgcHVibGlzaEpvdXJuYWw6IGFzeW5jIChqb3VybmFsSWQ6IG51bWJlciwgcHVibGljYXRpb25OdW1iZXI6IHN0cmluZykgPT4ge1xuICAgIC8vIFVzZSBwdWJsaWNhdGlvbl9udW1iZXIgdG8gbWF0Y2ggdGhlIGJhY2tlbmQncyBleHBlY3RlZCBwYXJhbWV0ZXIgbmFtZVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnB1dChgL2pvdXJuYWxzLyR7am91cm5hbElkfS9wdWJsaXNoYCwgeyBwdWJsaWNhdGlvbl9udW1iZXI6IHB1YmxpY2F0aW9uTnVtYmVyIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuICB1bnB1Ymxpc2hKb3VybmFsOiBhc3luYyAoam91cm5hbElkOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wdXQoYC9qb3VybmFscy8ke2pvdXJuYWxJZH0vdW5wdWJsaXNoYCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG59O1xuXG4vLyBSZXZpZXcgQVBJXG5leHBvcnQgY29uc3QgcmV2aWV3QVBJID0ge1xuICBnZXRKb3VybmFsUmV2aWV3czogYXN5bmMgKGpvdXJuYWxJZDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KGAvcmV2aWV3cy9qb3VybmFsLyR7am91cm5hbElkfWApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIGdldEFzc2lnbmVkUmV2aWV3czogYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL3Jldmlld3MvYXNzaWduZWQnKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFwaTtcbiJdLCJuYW1lcyI6WyJjb3JzQXdhcmVBcGkiLCJhcGkiLCJhdXRoQVBJIiwicmVnaXN0ZXIiLCJmb3JtRGF0YSIsInJlc3BvbnNlIiwicG9zdCIsImhlYWRlcnMiLCJkYXRhIiwidmVyaWZ5RW1haWwiLCJlbWFpbCIsIm90cCIsInJlc2VuZE9UUCIsImxvZ2luIiwicGFzc3dvcmQiLCJnZXRQcm9maWxlIiwiZ2V0IiwiY2hhbmdlUGFzc3dvcmQiLCJjdXJyZW50UGFzc3dvcmQiLCJuZXdQYXNzd29yZCIsInB1dCIsInJlc2V0UGFzc3dvcmQiLCJ1c2VySWQiLCJmb3Jnb3RQYXNzd29yZCIsInZlcmlmeVJlc2V0VG9rZW4iLCJ0b2tlbiIsInJlc2V0UGFzc3dvcmRXaXRoVG9rZW4iLCJ1c2VyQVBJIiwiZ2V0QWxsVXNlcnMiLCJyb2xlIiwicGFyYW1zIiwiZ2V0VXNlckJ5SWQiLCJpZCIsImNyZWF0ZVVzZXIiLCJ1c2VyRGF0YSIsInVwZGF0ZVVzZXIiLCJkZWxldGVVc2VyIiwiZGVsZXRlIiwiam91cm5hbEFQSSIsImdldFB1Ymxpc2hlZEpvdXJuYWxzIiwiZmlsdGVycyIsInNvcnRfYnkiLCJzb3J0X29yZGVyIiwic2VhcmNoIiwibGltaXQiLCJwYWdlIiwiX3QiLCJEYXRlIiwiZ2V0VGltZSIsImNvbnNvbGUiLCJsb2ciLCJjcmVhdGVKb3VybmFsIiwiZ2V0QWxsSm91cm5hbHMiLCJnZXRKb3VybmFsQnlJZCIsImVycm9yIiwiZ2V0QWxsUmV2aWV3ZXJzIiwiYXNzaWduUmV2aWV3ZXIiLCJqb3VybmFsSWQiLCJyZXZpZXdlcklkIiwicmV2aWV3ZXJfaWQiLCJyZXZpZXdKb3VybmFsIiwic3RhdHVzIiwiY29tbWVudHMiLCJnZXRKb3VybmFsRmlsZSIsImRvd25sb2FkSm91cm5hbCIsImpvdXJuYWwiLCJmaWxlSW5mbyIsImRvd25sb2FkVXJsIiwid2luZG93Iiwib3BlbiIsImEiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsImRpc3BsYXkiLCJhcGlCYXNlVXJsIiwiQkFDS0VORF9VUkwiLCJyZXBsYWNlIiwiaHJlZiIsImluY2x1ZGVzIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNsaWNrIiwicmVtb3ZlQ2hpbGQiLCJkZWxldGVKb3VybmFsIiwidXBkYXRlSm91cm5hbFN0YXR1cyIsInB1Ymxpc2hKb3VybmFsIiwicHVibGljYXRpb25OdW1iZXIiLCJwdWJsaWNhdGlvbl9udW1iZXIiLCJ1bnB1Ymxpc2hKb3VybmFsIiwicmV2aWV3QVBJIiwiZ2V0Sm91cm5hbFJldmlld3MiLCJnZXRBc3NpZ25lZFJldmlld3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utils/api.ts\n"));

/***/ }),

/***/ "./src/utils/corsAwareApi.js":
/*!***********************************!*\
  !*** ./src/utils/corsAwareApi.js ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/**\n * CORS-Aware API Client\n * \n * This utility creates an API client that can handle CORS issues in both\n * development and production environments.\n */ \n// Determine if we're in a browser environment\nconst isBrowser = \"object\" !== \"undefined\";\n// Get the appropriate API URL based on environment variables\nconst getApiBaseUrl = ()=>{\n    // Use environment variable if available\n    if (true) {\n        return \"https://nbu-journal-api.onrender.com/api\";\n    }\n    // Fallback to production URL\n    return \"https://nbu-journal-api.onrender.com/api\";\n};\n// Create the API client\nconst createApiClient = ()=>{\n    const baseURL = getApiBaseUrl();\n    console.log(\"Creating API client with base URL:\", baseURL);\n    // Create axios instance\n    const api = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n        baseURL,\n        headers: {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\"\n        },\n        withCredentials: true\n    });\n    // Add request interceptor to handle auth tokens\n    api.interceptors.request.use((config)=>{\n        // Only try to get token in browser environment\n        if (isBrowser) {\n            const token = localStorage.getItem(\"token\");\n            if (token) {\n                config.headers.Authorization = \"Bearer \".concat(token);\n            }\n        }\n        // Log request details in development\n        if (true) {\n            var _config_method;\n            console.log(\"[API Request] \".concat((_config_method = config.method) === null || _config_method === void 0 ? void 0 : _config_method.toUpperCase(), \" \").concat(config.url));\n        }\n        return config;\n    }, (error)=>Promise.reject(error));\n    // Add response interceptor for better error handling\n    api.interceptors.response.use((response)=>response, (error)=>{\n        // Handle CORS errors specifically\n        if (error.message === \"Network Error\") {\n            console.error(\"[API] CORS or Network Error:\", error);\n            // Log helpful information for debugging\n            if (true) {\n                console.error(\"\\n            [API] Possible CORS issue detected:\\n            - Frontend Origin: \".concat(window.location.origin, \"\\n            - API Endpoint: \").concat(baseURL, \"\\n            \\n            Make sure your backend CORS configuration includes:\\n            - \").concat(window.location.origin, \"\\n            \\n            If using local development:\\n            1. Make sure your backend is running\\n            2. Check CORS configuration in backend/server.js\\n          \"));\n            }\n        }\n        return Promise.reject(error);\n    });\n    return api;\n};\n// Create and export the API client\nconst api = createApiClient();\n/* harmony default export */ __webpack_exports__[\"default\"] = (api);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMvY29yc0F3YXJlQXBpLmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7O0NBS0MsR0FFeUI7QUFFMUIsOENBQThDO0FBQzlDLE1BQU1DLFlBQVksYUFBa0I7QUFFcEMsNkRBQTZEO0FBQzdELE1BQU1DLGdCQUFnQjtJQUNwQix3Q0FBd0M7SUFDeEMsSUFBSUMsSUFBK0IsRUFBRTtRQUNuQyxPQUFPQSwwQ0FBK0I7SUFDeEM7SUFFQSw2QkFBNkI7SUFDN0IsT0FBTztBQUNUO0FBRUEsd0JBQXdCO0FBQ3hCLE1BQU1HLGtCQUFrQjtJQUN0QixNQUFNQyxVQUFVTDtJQUVoQk0sUUFBUUMsR0FBRyxDQUFDLHNDQUFzQ0Y7SUFFbEQsd0JBQXdCO0lBQ3hCLE1BQU1HLE1BQU1WLG9EQUFZLENBQUM7UUFDdkJPO1FBQ0FLLFNBQVM7WUFDUCxnQkFBZ0I7WUFDaEIsVUFBVTtRQUNaO1FBQ0FDLGlCQUFpQjtJQUNuQjtJQUVBLGdEQUFnRDtJQUNoREgsSUFBSUksWUFBWSxDQUFDQyxPQUFPLENBQUNDLEdBQUcsQ0FDMUIsQ0FBQ0M7UUFDQywrQ0FBK0M7UUFDL0MsSUFBSWhCLFdBQVc7WUFDYixNQUFNaUIsUUFBUUMsYUFBYUMsT0FBTyxDQUFDO1lBQ25DLElBQUlGLE9BQU87Z0JBQ1RELE9BQU9MLE9BQU8sQ0FBQ1MsYUFBYSxHQUFHLFVBQWdCLE9BQU5IO1lBQzNDO1FBQ0Y7UUFFQSxxQ0FBcUM7UUFDckMsSUFBSWYsSUFBeUIsRUFBZTtnQkFDYmM7WUFBN0JULFFBQVFDLEdBQUcsQ0FBQyxpQkFBaURRLFFBQWhDQSxpQkFBQUEsT0FBT0ssTUFBTSxjQUFiTCxxQ0FBQUEsZUFBZU0sV0FBVyxJQUFHLEtBQWMsT0FBWE4sT0FBT08sR0FBRztRQUN6RTtRQUVBLE9BQU9QO0lBQ1QsR0FDQSxDQUFDUSxRQUFVQyxRQUFRQyxNQUFNLENBQUNGO0lBRzVCLHFEQUFxRDtJQUNyRGYsSUFBSUksWUFBWSxDQUFDYyxRQUFRLENBQUNaLEdBQUcsQ0FDM0IsQ0FBQ1ksV0FBYUEsVUFDZCxDQUFDSDtRQUNDLGtDQUFrQztRQUNsQyxJQUFJQSxNQUFNSSxPQUFPLEtBQUssaUJBQWlCO1lBQ3JDckIsUUFBUWlCLEtBQUssQ0FBQyxnQ0FBZ0NBO1lBRTlDLHdDQUF3QztZQUN4QyxJQUFJdEIsSUFBeUIsRUFBZTtnQkFDMUNLLFFBQVFpQixLQUFLLENBQUMscUZBR01sQixPQURHdUIsT0FBT0MsUUFBUSxDQUFDQyxNQUFNLEVBQUMsa0NBSXhDRixPQUhjdkIsU0FBUSxtR0FHQyxPQUF2QnVCLE9BQU9DLFFBQVEsQ0FBQ0MsTUFBTSxFQUFDO1lBTS9CO1FBQ0Y7UUFFQSxPQUFPTixRQUFRQyxNQUFNLENBQUNGO0lBQ3hCO0lBR0YsT0FBT2Y7QUFDVDtBQUVBLG1DQUFtQztBQUNuQyxNQUFNQSxNQUFNSjtBQUVaLCtEQUFlSSxHQUFHQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy9jb3JzQXdhcmVBcGkuanM/NDRmZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENPUlMtQXdhcmUgQVBJIENsaWVudFxuICogXG4gKiBUaGlzIHV0aWxpdHkgY3JlYXRlcyBhbiBBUEkgY2xpZW50IHRoYXQgY2FuIGhhbmRsZSBDT1JTIGlzc3VlcyBpbiBib3RoXG4gKiBkZXZlbG9wbWVudCBhbmQgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMuXG4gKi9cblxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcblxuLy8gRGV0ZXJtaW5lIGlmIHdlJ3JlIGluIGEgYnJvd3NlciBlbnZpcm9ubWVudFxuY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIEdldCB0aGUgYXBwcm9wcmlhdGUgQVBJIFVSTCBiYXNlZCBvbiBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbmNvbnN0IGdldEFwaUJhc2VVcmwgPSAoKSA9PiB7XG4gIC8vIFVzZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpZiBhdmFpbGFibGVcbiAgaWYgKHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTDtcbiAgfVxuICBcbiAgLy8gRmFsbGJhY2sgdG8gcHJvZHVjdGlvbiBVUkxcbiAgcmV0dXJuICdodHRwczovL25idS1qb3VybmFsLWFwaS5vbnJlbmRlci5jb20vYXBpJztcbn07XG5cbi8vIENyZWF0ZSB0aGUgQVBJIGNsaWVudFxuY29uc3QgY3JlYXRlQXBpQ2xpZW50ID0gKCkgPT4ge1xuICBjb25zdCBiYXNlVVJMID0gZ2V0QXBpQmFzZVVybCgpO1xuICBcbiAgY29uc29sZS5sb2coJ0NyZWF0aW5nIEFQSSBjbGllbnQgd2l0aCBiYXNlIFVSTDonLCBiYXNlVVJMKTtcbiAgXG4gIC8vIENyZWF0ZSBheGlvcyBpbnN0YW5jZVxuICBjb25zdCBhcGkgPSBheGlvcy5jcmVhdGUoe1xuICAgIGJhc2VVUkwsXG4gICAgaGVhZGVyczoge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgfSxcbiAgICB3aXRoQ3JlZGVudGlhbHM6IHRydWUsXG4gIH0pO1xuICBcbiAgLy8gQWRkIHJlcXVlc3QgaW50ZXJjZXB0b3IgdG8gaGFuZGxlIGF1dGggdG9rZW5zXG4gIGFwaS5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoXG4gICAgKGNvbmZpZykgPT4ge1xuICAgICAgLy8gT25seSB0cnkgdG8gZ2V0IHRva2VuIGluIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKTtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgY29uZmlnLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGBCZWFyZXIgJHt0b2tlbn1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIExvZyByZXF1ZXN0IGRldGFpbHMgaW4gZGV2ZWxvcG1lbnRcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0FQSSBSZXF1ZXN0XSAke2NvbmZpZy5tZXRob2Q/LnRvVXBwZXJDYXNlKCl9ICR7Y29uZmlnLnVybH1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9LFxuICAgIChlcnJvcikgPT4gUHJvbWlzZS5yZWplY3QoZXJyb3IpXG4gICk7XG4gIFxuICAvLyBBZGQgcmVzcG9uc2UgaW50ZXJjZXB0b3IgZm9yIGJldHRlciBlcnJvciBoYW5kbGluZ1xuICBhcGkuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLnVzZShcbiAgICAocmVzcG9uc2UpID0+IHJlc3BvbnNlLFxuICAgIChlcnJvcikgPT4ge1xuICAgICAgLy8gSGFuZGxlIENPUlMgZXJyb3JzIHNwZWNpZmljYWxseVxuICAgICAgaWYgKGVycm9yLm1lc3NhZ2UgPT09ICdOZXR3b3JrIEVycm9yJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbQVBJXSBDT1JTIG9yIE5ldHdvcmsgRXJyb3I6JywgZXJyb3IpO1xuICAgICAgICBcbiAgICAgICAgLy8gTG9nIGhlbHBmdWwgaW5mb3JtYXRpb24gZm9yIGRlYnVnZ2luZ1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBcbiAgICAgICAgICAgIFtBUEldIFBvc3NpYmxlIENPUlMgaXNzdWUgZGV0ZWN0ZWQ6XG4gICAgICAgICAgICAtIEZyb250ZW5kIE9yaWdpbjogJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufVxuICAgICAgICAgICAgLSBBUEkgRW5kcG9pbnQ6ICR7YmFzZVVSTH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgTWFrZSBzdXJlIHlvdXIgYmFja2VuZCBDT1JTIGNvbmZpZ3VyYXRpb24gaW5jbHVkZXM6XG4gICAgICAgICAgICAtICR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgSWYgdXNpbmcgbG9jYWwgZGV2ZWxvcG1lbnQ6XG4gICAgICAgICAgICAxLiBNYWtlIHN1cmUgeW91ciBiYWNrZW5kIGlzIHJ1bm5pbmdcbiAgICAgICAgICAgIDIuIENoZWNrIENPUlMgY29uZmlndXJhdGlvbiBpbiBiYWNrZW5kL3NlcnZlci5qc1xuICAgICAgICAgIGApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICApO1xuICBcbiAgcmV0dXJuIGFwaTtcbn07XG5cbi8vIENyZWF0ZSBhbmQgZXhwb3J0IHRoZSBBUEkgY2xpZW50XG5jb25zdCBhcGkgPSBjcmVhdGVBcGlDbGllbnQoKTtcblxuZXhwb3J0IGRlZmF1bHQgYXBpO1xuIl0sIm5hbWVzIjpbImF4aW9zIiwiaXNCcm93c2VyIiwiZ2V0QXBpQmFzZVVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiY3JlYXRlQXBpQ2xpZW50IiwiYmFzZVVSTCIsImNvbnNvbGUiLCJsb2ciLCJhcGkiLCJjcmVhdGUiLCJoZWFkZXJzIiwid2l0aENyZWRlbnRpYWxzIiwiaW50ZXJjZXB0b3JzIiwicmVxdWVzdCIsInVzZSIsImNvbmZpZyIsInRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIkF1dGhvcml6YXRpb24iLCJtZXRob2QiLCJ0b1VwcGVyQ2FzZSIsInVybCIsImVycm9yIiwiUHJvbWlzZSIsInJlamVjdCIsInJlc3BvbnNlIiwibWVzc2FnZSIsIndpbmRvdyIsImxvY2F0aW9uIiwib3JpZ2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utils/corsAwareApi.js\n"));

/***/ })

});