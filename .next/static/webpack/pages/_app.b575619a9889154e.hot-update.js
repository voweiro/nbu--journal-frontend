"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/utils/api.ts":
/*!**************************!*\
  !*** ./src/utils/api.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authAPI: function() { return /* binding */ authAPI; },\n/* harmony export */   journalAPI: function() { return /* binding */ journalAPI; },\n/* harmony export */   reviewAPI: function() { return /* binding */ reviewAPI; },\n/* harmony export */   userAPI: function() { return /* binding */ userAPI; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n\n// Check if code is running in browser environment\nconst isBrowser = \"object\" !== \"undefined\";\n// Determine the API URL based on environment variables\nconst getApiBaseUrl = ()=>{\n    // Use the environment variable if available\n    if (true) {\n        return \"https://nbu-journal-backend.onrender.com/api\";\n    }\n    // Fallback values based on environment\n    if (true) {\n        return \"http://localhost:8000/api\";\n    }\n    // Production fallback\n    return \"https://nbu-journal-backend.onrender.com/api\";\n};\nconst BACKEND_URL = getApiBaseUrl();\n// Log the API URL for debugging\nconsole.log(\"Using API URL:\", BACKEND_URL);\n// Create axios instance with the appropriate backend URL\nconst api = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: BACKEND_URL,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n    withCredentials: true\n});\nconsole.log(\"API configured with URL:\", BACKEND_URL);\n// Add auth token to requests if available\napi.interceptors.request.use((config)=>{\n    // Only try to get token from localStorage in browser environment\n    if (isBrowser) {\n        const token = localStorage.getItem(\"token\");\n        if (token) {\n            config.headers.Authorization = \"Bearer \".concat(token);\n        }\n    }\n    console.log(\"Making request to:\", config.url, \"with baseURL:\", config.baseURL);\n    return config;\n}, (error)=>Promise.reject(error));\n// Auth API\nconst authAPI = {\n    register: async (formData)=>{\n        const response = await api.post(\"/auth/register\", formData, {\n            headers: {\n                \"Content-Type\": \"multipart/form-data\"\n            }\n        });\n        return response.data;\n    },\n    verifyEmail: async (email, otp)=>{\n        const response = await api.post(\"/auth/verify-email\", {\n            email,\n            otp\n        });\n        return response.data;\n    },\n    resendOTP: async (email)=>{\n        const response = await api.post(\"/auth/resend-otp\", {\n            email\n        });\n        return response.data;\n    },\n    login: async (email, password)=>{\n        const response = await api.post(\"/auth/login\", {\n            email,\n            password\n        });\n        return response.data;\n    },\n    getProfile: async ()=>{\n        const response = await api.get(\"/auth/profile\");\n        return response.data;\n    },\n    changePassword: async (currentPassword, newPassword)=>{\n        const response = await api.put(\"/auth/change-password\", {\n            currentPassword,\n            newPassword\n        });\n        return response.data;\n    },\n    resetPassword: async (userId, newPassword)=>{\n        const response = await api.put(\"/auth/reset-password\", {\n            userId,\n            newPassword\n        });\n        return response.data;\n    },\n    forgotPassword: async (email)=>{\n        const response = await api.post(\"/auth/forgot-password\", {\n            email\n        });\n        return response.data;\n    },\n    verifyResetToken: async (email, token)=>{\n        const response = await api.post(\"/auth/verify-reset-token\", {\n            email,\n            token\n        });\n        return response.data;\n    },\n    resetPasswordWithToken: async (email, token, password)=>{\n        const response = await api.post(\"/auth/reset-password-with-token\", {\n            email,\n            token,\n            password\n        });\n        return response.data;\n    }\n};\n// User API\nconst userAPI = {\n    getAllUsers: async (role)=>{\n        const response = await api.get(\"/users\", {\n            params: {\n                role\n            }\n        });\n        return response.data;\n    },\n    getUserById: async (id)=>{\n        const response = await api.get(\"/users/\".concat(id));\n        return response.data;\n    },\n    createUser: async (userData)=>{\n        const response = await api.post(\"/users\", userData);\n        return response.data;\n    },\n    updateUser: async (id, formData)=>{\n        const response = await api.put(\"/users/\".concat(id), formData, {\n            headers: {\n                \"Content-Type\": \"multipart/form-data\"\n            }\n        });\n        return response.data;\n    },\n    deleteUser: async (id)=>{\n        const response = await api.delete(\"/users/\".concat(id));\n        return response.data;\n    },\n    resetPassword: async (userId, newPassword)=>{\n        const response = await api.post(\"/auth/reset-password\", {\n            userId,\n            newPassword\n        });\n        return response.data;\n    }\n};\n// Journal API\nconst journalAPI = {\n    getPublishedJournals: async function() {\n        let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        // Use params object instead of manually constructing URL\n        const response = await api.get(\"/journals/published\", {\n            params: {\n                sort_by: filters.sort_by || \"published_date\",\n                sort_order: filters.sort_order || \"DESC\",\n                search: filters.search || \"\",\n                limit: filters.limit || null,\n                page: filters.page || null,\n                _t: new Date().getTime() // Cache-busting parameter\n            }\n        });\n        console.log(\"API response for published journals:\", response.data);\n        return response.data;\n    },\n    createJournal: async (formData)=>{\n        const response = await api.post(\"/journals\", formData, {\n            headers: {\n                \"Content-Type\": \"multipart/form-data\"\n            }\n        });\n        return response.data;\n    },\n    getAllJournals: async (filters)=>{\n        const response = await api.get(\"/journals\", {\n            params: filters\n        });\n        return response.data;\n    },\n    getJournalById: async (id)=>{\n        try {\n            // First try to get the journal as a published journal (no auth required)\n            const response = await api.get(\"/journals/published/\".concat(id));\n            return response.data;\n        } catch (error) {\n            // If that fails (e.g., journal is not published), fall back to the authenticated route\n            const response = await api.get(\"/journals/\".concat(id));\n            return response.data;\n        }\n    },\n    getAllReviewers: async ()=>{\n        const response = await api.get(\"/journals/reviewers\");\n        return response.data;\n    },\n    assignReviewer: async (journalId, reviewerId)=>{\n        const response = await api.put(\"/journals/\".concat(journalId, \"/assign\"), {\n            reviewer_id: reviewerId\n        });\n        return response.data;\n    },\n    reviewJournal: async (journalId, status, comments)=>{\n        const response = await api.put(\"/journals/\".concat(journalId, \"/review\"), {\n            status,\n            comments\n        });\n        return response.data;\n    },\n    getJournalFile: async (journalId)=>{\n        const response = await api.get(\"/journals/\".concat(journalId, \"/file\"));\n        return response.data;\n    },\n    downloadJournal: async (journalId)=>{\n        try {\n            // First try to get the journal to check if it's published\n            const { journal } = await journalAPI.getJournalById(journalId);\n            // For published journals, try to get file info from the public endpoint\n            let fileInfo;\n            try {\n                // For published journals, we can try the public endpoint first\n                if (journal.status === \"published\") {\n                    // Try to get file info from the public endpoint\n                    const response = await api.get(\"/journals/published/\".concat(journalId, \"/file\"));\n                    fileInfo = response.data;\n                } else {\n                    // For non-published journals, use the authenticated endpoint\n                    fileInfo = await journalAPI.getJournalFile(journalId);\n                }\n            } catch (error) {\n                console.log(\"Could not get file info, proceeding with direct download\", error);\n            }\n            // If we have Google Drive file info with a download URL, use that\n            if (fileInfo && fileInfo.downloadUrl) {\n                console.log(\"Using Google Drive download URL:\", fileInfo.downloadUrl);\n                window.open(fileInfo.downloadUrl, \"_blank\");\n                return;\n            }\n            // If Google Drive info is not available, try direct download\n            console.log(\"Falling back to direct download\");\n            // Create a temporary hidden anchor element\n            const a = document.createElement(\"a\");\n            a.style.display = \"none\";\n            // Use the hardcoded backend URL to avoid any caching issues\n            const apiBaseUrl = BACKEND_URL.replace(\"/api\", \"\");\n            // Use the public route for published journals, otherwise use the authenticated route\n            if (journal.status === \"published\") {\n                a.href = \"\".concat(apiBaseUrl, \"/api/journals/published/\").concat(journalId, \"/download\");\n                // Try alternative path if API base URL doesn't include /api\n                if (!apiBaseUrl.includes(\"/api\")) {\n                    a.href = \"\".concat(apiBaseUrl, \"/journals/published/\").concat(journalId, \"/download\");\n                }\n            } else {\n                // Fallback to the authenticated route\n                const token = localStorage.getItem(\"token\");\n                a.href = \"\".concat(apiBaseUrl, \"/api/journals/\").concat(journalId, \"/download\");\n                // Try alternative path if API base URL doesn't include /api\n                if (!apiBaseUrl.includes(\"/api\")) {\n                    a.href = \"\".concat(apiBaseUrl, \"/journals/\").concat(journalId, \"/download\");\n                }\n                // Add the token as a query parameter\n                if (token) {\n                    a.href += \"?token=\".concat(token);\n                }\n            }\n            console.log(\"Download URL:\", a.href);\n            // Append to body, click, and remove\n            document.body.appendChild(a);\n            a.click();\n            document.body.removeChild(a);\n        } catch (error) {\n            console.error(\"Error downloading journal:\", error);\n        }\n    },\n    deleteJournal: async (journalId)=>{\n        const response = await api.delete(\"/journals/\".concat(journalId));\n        return response.data;\n    },\n    updateJournalStatus: async (journalId, status)=>{\n        const response = await api.put(\"/journals/\".concat(journalId, \"/status\"), {\n            status\n        });\n        return response.data;\n    },\n    publishJournal: async (journalId, publicationNumber)=>{\n        // Use publication_number to match the backend's expected parameter name\n        const response = await api.put(\"/journals/\".concat(journalId, \"/publish\"), {\n            publication_number: publicationNumber\n        });\n        return response.data;\n    },\n    unpublishJournal: async (journalId)=>{\n        const response = await api.put(\"/journals/\".concat(journalId, \"/unpublish\"));\n        return response.data;\n    }\n};\n// Review API\nconst reviewAPI = {\n    getJournalReviews: async (journalId)=>{\n        const response = await api.get(\"/reviews/journal/\".concat(journalId));\n        return response.data;\n    },\n    getAssignedReviews: async ()=>{\n        const response = await api.get(\"/reviews/assigned\");\n        return response.data;\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (api);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFDL0IsT0FBT1YsU0FBU0UsSUFBSTtJQUN0QjtBQUNGLEVBQUU7QUFFRiwrREFBZXRCLEdBQUdBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL2FwaS50cz9iOTcwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgeyBVc2VyLCBKb3VybmFsLCBKb3VybmFsU3RhdHVzLCBKb3VybmFsRmlsdGVycyB9IGZyb20gJ0AvdHlwZXMnO1xuXG4vLyBDaGVjayBpZiBjb2RlIGlzIHJ1bm5pbmcgaW4gYnJvd3NlciBlbnZpcm9ubWVudFxuY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIERldGVybWluZSB0aGUgQVBJIFVSTCBiYXNlZCBvbiBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbmNvbnN0IGdldEFwaUJhc2VVcmwgPSAoKSA9PiB7XG4gIC8vIFVzZSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUgaWYgYXZhaWxhYmxlXG4gIGlmIChwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkw7XG4gIH1cbiAgXG4gIC8vIEZhbGxiYWNrIHZhbHVlcyBiYXNlZCBvbiBlbnZpcm9ubWVudFxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICByZXR1cm4gJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMC9hcGknO1xuICB9XG4gIFxuICAvLyBQcm9kdWN0aW9uIGZhbGxiYWNrXG4gIHJldHVybiAnaHR0cHM6Ly9uYnUtam91cm5hbC1iYWNrZW5kLm9ucmVuZGVyLmNvbS9hcGknO1xufTtcblxuY29uc3QgQkFDS0VORF9VUkwgPSBnZXRBcGlCYXNlVXJsKCk7XG5cbi8vIExvZyB0aGUgQVBJIFVSTCBmb3IgZGVidWdnaW5nXG5jb25zb2xlLmxvZygnVXNpbmcgQVBJIFVSTDonLCBCQUNLRU5EX1VSTCk7XG5cbi8vIENyZWF0ZSBheGlvcyBpbnN0YW5jZSB3aXRoIHRoZSBhcHByb3ByaWF0ZSBiYWNrZW5kIFVSTFxuY29uc3QgYXBpID0gYXhpb3MuY3JlYXRlKHtcbiAgYmFzZVVSTDogQkFDS0VORF9VUkwsXG4gIGhlYWRlcnM6IHtcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICB9LFxuICB3aXRoQ3JlZGVudGlhbHM6IHRydWUsIC8vIEltcG9ydGFudCBmb3IgY29va2llcy9hdXRoIGlmIG5lZWRlZFxufSk7XG5cbmNvbnNvbGUubG9nKCdBUEkgY29uZmlndXJlZCB3aXRoIFVSTDonLCBCQUNLRU5EX1VSTCk7XG5cbi8vIEFkZCBhdXRoIHRva2VuIHRvIHJlcXVlc3RzIGlmIGF2YWlsYWJsZVxuYXBpLmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZShcbiAgKGNvbmZpZykgPT4ge1xuICAgIC8vIE9ubHkgdHJ5IHRvIGdldCB0b2tlbiBmcm9tIGxvY2FsU3RvcmFnZSBpbiBicm93c2VyIGVudmlyb25tZW50XG4gICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKTtcbiAgICAgIGlmICh0b2tlbikge1xuICAgICAgICBjb25maWcuaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke3Rva2VufWA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKCdNYWtpbmcgcmVxdWVzdCB0bzonLCBjb25maWcudXJsLCAnd2l0aCBiYXNlVVJMOicsIGNvbmZpZy5iYXNlVVJMKTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9LFxuICAoZXJyb3IpID0+IFByb21pc2UucmVqZWN0KGVycm9yKVxuKTtcblxuLy8gQXV0aCBBUElcbmV4cG9ydCBjb25zdCBhdXRoQVBJID0ge1xuICByZWdpc3RlcjogYXN5bmMgKGZvcm1EYXRhOiBGb3JtRGF0YSkgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9hdXRoL3JlZ2lzdGVyJywgZm9ybURhdGEsIHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJyxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG5cbiAgdmVyaWZ5RW1haWw6IGFzeW5jIChlbWFpbDogc3RyaW5nLCBvdHA6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9hdXRoL3ZlcmlmeS1lbWFpbCcsIHsgZW1haWwsIG90cCB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcblxuICByZXNlbmRPVFA6IGFzeW5jIChlbWFpbDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdCgnL2F1dGgvcmVzZW5kLW90cCcsIHsgZW1haWwgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG5cbiAgbG9naW46IGFzeW5jIChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdCgnL2F1dGgvbG9naW4nLCB7IGVtYWlsLCBwYXNzd29yZCB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcblxuICBnZXRQcm9maWxlOiBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KCcvYXV0aC9wcm9maWxlJyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG5cbiAgY2hhbmdlUGFzc3dvcmQ6IGFzeW5jIChjdXJyZW50UGFzc3dvcmQ6IHN0cmluZywgbmV3UGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnB1dCgnL2F1dGgvY2hhbmdlLXBhc3N3b3JkJywge1xuICAgICAgY3VycmVudFBhc3N3b3JkLFxuICAgICAgbmV3UGFzc3dvcmQsXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG5cbiAgcmVzZXRQYXNzd29yZDogYXN5bmMgKHVzZXJJZDogbnVtYmVyLCBuZXdQYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucHV0KCcvYXV0aC9yZXNldC1wYXNzd29yZCcsIHtcbiAgICAgIHVzZXJJZCxcbiAgICAgIG5ld1Bhc3N3b3JkLFxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIGZvcmdvdFBhc3N3b3JkOiBhc3luYyAoZW1haWw6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9hdXRoL2ZvcmdvdC1wYXNzd29yZCcsIHsgZW1haWwgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG5cbiAgdmVyaWZ5UmVzZXRUb2tlbjogYXN5bmMgKGVtYWlsOiBzdHJpbmcsIHRva2VuOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvYXV0aC92ZXJpZnktcmVzZXQtdG9rZW4nLCB7IGVtYWlsLCB0b2tlbiB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcblxuICByZXNldFBhc3N3b3JkV2l0aFRva2VuOiBhc3luYyAoZW1haWw6IHN0cmluZywgdG9rZW46IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9hdXRoL3Jlc2V0LXBhc3N3b3JkLXdpdGgtdG9rZW4nLCB7IGVtYWlsLCB0b2tlbiwgcGFzc3dvcmQgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG59O1xuXG4vLyBVc2VyIEFQSVxuZXhwb3J0IGNvbnN0IHVzZXJBUEkgPSB7XG4gIGdldEFsbFVzZXJzOiBhc3luYyAocm9sZT86IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL3VzZXJzJywge1xuICAgICAgcGFyYW1zOiB7IHJvbGUgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcblxuICBnZXRVc2VyQnlJZDogYXN5bmMgKGlkOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoYC91c2Vycy8ke2lkfWApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIGNyZWF0ZVVzZXI6IGFzeW5jICh1c2VyRGF0YToge1xuICAgIHVzZXJuYW1lOiBzdHJpbmc7XG4gICAgZW1haWw6IHN0cmluZztcbiAgICBwYXNzd29yZDogc3RyaW5nO1xuICAgIGZpcnN0X25hbWU6IHN0cmluZztcbiAgICBsYXN0X25hbWU6IHN0cmluZztcbiAgICByb2xlOiBzdHJpbmc7XG4gICAgZGVwYXJ0bWVudD86IHN0cmluZztcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy91c2VycycsIHVzZXJEYXRhKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcblxuICB1cGRhdGVVc2VyOiBhc3luYyAoaWQ6IG51bWJlciwgZm9ybURhdGE6IEZvcm1EYXRhKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucHV0KGAvdXNlcnMvJHtpZH1gLCBmb3JtRGF0YSwge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGEnLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcblxuICBkZWxldGVVc2VyOiBhc3luYyAoaWQ6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmRlbGV0ZShgL3VzZXJzLyR7aWR9YCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG5cbiAgcmVzZXRQYXNzd29yZDogYXN5bmMgKHVzZXJJZDogbnVtYmVyLCBuZXdQYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdChgL2F1dGgvcmVzZXQtcGFzc3dvcmRgLCB7IHVzZXJJZCwgbmV3UGFzc3dvcmQgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG59O1xuXG4vLyBKb3VybmFsIEFQSVxuZXhwb3J0IGNvbnN0IGpvdXJuYWxBUEkgPSB7XG4gIGdldFB1Ymxpc2hlZEpvdXJuYWxzOiBhc3luYyAoZmlsdGVyczogSm91cm5hbEZpbHRlcnMgPSB7fSkgPT4ge1xuICAgIC8vIFVzZSBwYXJhbXMgb2JqZWN0IGluc3RlYWQgb2YgbWFudWFsbHkgY29uc3RydWN0aW5nIFVSTFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL2pvdXJuYWxzL3B1Ymxpc2hlZCcsIHtcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBzb3J0X2J5OiBmaWx0ZXJzLnNvcnRfYnkgfHwgJ3B1Ymxpc2hlZF9kYXRlJyxcbiAgICAgICAgc29ydF9vcmRlcjogZmlsdGVycy5zb3J0X29yZGVyIHx8ICdERVNDJyxcbiAgICAgICAgc2VhcmNoOiBmaWx0ZXJzLnNlYXJjaCB8fCAnJyxcbiAgICAgICAgbGltaXQ6IGZpbHRlcnMubGltaXQgfHwgbnVsbCxcbiAgICAgICAgcGFnZTogZmlsdGVycy5wYWdlIHx8IG51bGwsXG4gICAgICAgIF90OiBuZXcgRGF0ZSgpLmdldFRpbWUoKSAvLyBDYWNoZS1idXN0aW5nIHBhcmFtZXRlclxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKCdBUEkgcmVzcG9uc2UgZm9yIHB1Ymxpc2hlZCBqb3VybmFsczonLCByZXNwb25zZS5kYXRhKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcbiAgXG4gIGNyZWF0ZUpvdXJuYWw6IGFzeW5jIChmb3JtRGF0YTogRm9ybURhdGEpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvam91cm5hbHMnLCBmb3JtRGF0YSwge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGEnLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcblxuICBnZXRBbGxKb3VybmFsczogYXN5bmMgKGZpbHRlcnM/OiBKb3VybmFsRmlsdGVycykgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL2pvdXJuYWxzJywge1xuICAgICAgcGFyYW1zOiBmaWx0ZXJzLFxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIGdldEpvdXJuYWxCeUlkOiBhc3luYyAoaWQ6IG51bWJlcikgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBGaXJzdCB0cnkgdG8gZ2V0IHRoZSBqb3VybmFsIGFzIGEgcHVibGlzaGVkIGpvdXJuYWwgKG5vIGF1dGggcmVxdWlyZWQpXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoYC9qb3VybmFscy9wdWJsaXNoZWQvJHtpZH1gKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZiB0aGF0IGZhaWxzIChlLmcuLCBqb3VybmFsIGlzIG5vdCBwdWJsaXNoZWQpLCBmYWxsIGJhY2sgdG8gdGhlIGF1dGhlbnRpY2F0ZWQgcm91dGVcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldChgL2pvdXJuYWxzLyR7aWR9YCk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0QWxsUmV2aWV3ZXJzOiBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KCcvam91cm5hbHMvcmV2aWV3ZXJzJyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG5cbiAgYXNzaWduUmV2aWV3ZXI6IGFzeW5jIChqb3VybmFsSWQ6IG51bWJlciwgcmV2aWV3ZXJJZDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucHV0KGAvam91cm5hbHMvJHtqb3VybmFsSWR9L2Fzc2lnbmAsIHtcbiAgICAgIHJldmlld2VyX2lkOiByZXZpZXdlcklkLFxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIHJldmlld0pvdXJuYWw6IGFzeW5jIChqb3VybmFsSWQ6IG51bWJlciwgc3RhdHVzOiAnYXBwcm92ZWQnIHwgJ3JlamVjdGVkJywgY29tbWVudHM6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnB1dChgL2pvdXJuYWxzLyR7am91cm5hbElkfS9yZXZpZXdgLCB7XG4gICAgICBzdGF0dXMsXG4gICAgICBjb21tZW50cyxcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcblxuICBnZXRKb3VybmFsRmlsZTogYXN5bmMgKGpvdXJuYWxJZDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KGAvam91cm5hbHMvJHtqb3VybmFsSWR9L2ZpbGVgKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcbiAgXG4gIGRvd25sb2FkSm91cm5hbDogYXN5bmMgKGpvdXJuYWxJZDogbnVtYmVyKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpcnN0IHRyeSB0byBnZXQgdGhlIGpvdXJuYWwgdG8gY2hlY2sgaWYgaXQncyBwdWJsaXNoZWRcbiAgICAgIGNvbnN0IHsgam91cm5hbCB9ID0gYXdhaXQgam91cm5hbEFQSS5nZXRKb3VybmFsQnlJZChqb3VybmFsSWQpO1xuICAgICAgXG4gICAgICAvLyBGb3IgcHVibGlzaGVkIGpvdXJuYWxzLCB0cnkgdG8gZ2V0IGZpbGUgaW5mbyBmcm9tIHRoZSBwdWJsaWMgZW5kcG9pbnRcbiAgICAgIGxldCBmaWxlSW5mbztcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEZvciBwdWJsaXNoZWQgam91cm5hbHMsIHdlIGNhbiB0cnkgdGhlIHB1YmxpYyBlbmRwb2ludCBmaXJzdFxuICAgICAgICBpZiAoam91cm5hbC5zdGF0dXMgPT09ICdwdWJsaXNoZWQnKSB7XG4gICAgICAgICAgLy8gVHJ5IHRvIGdldCBmaWxlIGluZm8gZnJvbSB0aGUgcHVibGljIGVuZHBvaW50XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KGAvam91cm5hbHMvcHVibGlzaGVkLyR7am91cm5hbElkfS9maWxlYCk7XG4gICAgICAgICAgZmlsZUluZm8gPSByZXNwb25zZS5kYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZvciBub24tcHVibGlzaGVkIGpvdXJuYWxzLCB1c2UgdGhlIGF1dGhlbnRpY2F0ZWQgZW5kcG9pbnRcbiAgICAgICAgICBmaWxlSW5mbyA9IGF3YWl0IGpvdXJuYWxBUEkuZ2V0Sm91cm5hbEZpbGUoam91cm5hbElkKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0NvdWxkIG5vdCBnZXQgZmlsZSBpbmZvLCBwcm9jZWVkaW5nIHdpdGggZGlyZWN0IGRvd25sb2FkJywgZXJyb3IpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiB3ZSBoYXZlIEdvb2dsZSBEcml2ZSBmaWxlIGluZm8gd2l0aCBhIGRvd25sb2FkIFVSTCwgdXNlIHRoYXRcbiAgICAgIGlmIChmaWxlSW5mbyAmJiBmaWxlSW5mby5kb3dubG9hZFVybCkge1xuICAgICAgICBjb25zb2xlLmxvZygnVXNpbmcgR29vZ2xlIERyaXZlIGRvd25sb2FkIFVSTDonLCBmaWxlSW5mby5kb3dubG9hZFVybCk7XG4gICAgICAgIHdpbmRvdy5vcGVuKGZpbGVJbmZvLmRvd25sb2FkVXJsLCAnX2JsYW5rJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgR29vZ2xlIERyaXZlIGluZm8gaXMgbm90IGF2YWlsYWJsZSwgdHJ5IGRpcmVjdCBkb3dubG9hZFxuICAgICAgY29uc29sZS5sb2coJ0ZhbGxpbmcgYmFjayB0byBkaXJlY3QgZG93bmxvYWQnKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGhpZGRlbiBhbmNob3IgZWxlbWVudFxuICAgICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgIGEuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIFxuICAgICAgLy8gVXNlIHRoZSBoYXJkY29kZWQgYmFja2VuZCBVUkwgdG8gYXZvaWQgYW55IGNhY2hpbmcgaXNzdWVzXG4gICAgICBjb25zdCBhcGlCYXNlVXJsID0gQkFDS0VORF9VUkwucmVwbGFjZSgnL2FwaScsICcnKTtcbiAgICAgIFxuICAgICAgLy8gVXNlIHRoZSBwdWJsaWMgcm91dGUgZm9yIHB1Ymxpc2hlZCBqb3VybmFscywgb3RoZXJ3aXNlIHVzZSB0aGUgYXV0aGVudGljYXRlZCByb3V0ZVxuICAgICAgaWYgKGpvdXJuYWwuc3RhdHVzID09PSAncHVibGlzaGVkJykge1xuICAgICAgICBhLmhyZWYgPSBgJHthcGlCYXNlVXJsfS9hcGkvam91cm5hbHMvcHVibGlzaGVkLyR7am91cm5hbElkfS9kb3dubG9hZGA7XG4gICAgICAgIC8vIFRyeSBhbHRlcm5hdGl2ZSBwYXRoIGlmIEFQSSBiYXNlIFVSTCBkb2Vzbid0IGluY2x1ZGUgL2FwaVxuICAgICAgICBpZiAoIWFwaUJhc2VVcmwuaW5jbHVkZXMoJy9hcGknKSkge1xuICAgICAgICAgIGEuaHJlZiA9IGAke2FwaUJhc2VVcmx9L2pvdXJuYWxzL3B1Ymxpc2hlZC8ke2pvdXJuYWxJZH0vZG93bmxvYWRgO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGYWxsYmFjayB0byB0aGUgYXV0aGVudGljYXRlZCByb3V0ZVxuICAgICAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpO1xuICAgICAgICBhLmhyZWYgPSBgJHthcGlCYXNlVXJsfS9hcGkvam91cm5hbHMvJHtqb3VybmFsSWR9L2Rvd25sb2FkYDtcbiAgICAgICAgLy8gVHJ5IGFsdGVybmF0aXZlIHBhdGggaWYgQVBJIGJhc2UgVVJMIGRvZXNuJ3QgaW5jbHVkZSAvYXBpXG4gICAgICAgIGlmICghYXBpQmFzZVVybC5pbmNsdWRlcygnL2FwaScpKSB7XG4gICAgICAgICAgYS5ocmVmID0gYCR7YXBpQmFzZVVybH0vam91cm5hbHMvJHtqb3VybmFsSWR9L2Rvd25sb2FkYDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQWRkIHRoZSB0b2tlbiBhcyBhIHF1ZXJ5IHBhcmFtZXRlclxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICBhLmhyZWYgKz0gYD90b2tlbj0ke3Rva2VufWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ0Rvd25sb2FkIFVSTDonLCBhLmhyZWYpO1xuICAgICAgXG4gICAgICAvLyBBcHBlbmQgdG8gYm9keSwgY2xpY2ssIGFuZCByZW1vdmVcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSk7XG4gICAgICBhLmNsaWNrKCk7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkb3dubG9hZGluZyBqb3VybmFsOicsIGVycm9yKTtcbiAgICB9XG4gIH0sXG4gIFxuICBkZWxldGVKb3VybmFsOiBhc3luYyAoam91cm5hbElkOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5kZWxldGUoYC9qb3VybmFscy8ke2pvdXJuYWxJZH1gKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcbiAgXG4gIHVwZGF0ZUpvdXJuYWxTdGF0dXM6IGFzeW5jIChqb3VybmFsSWQ6IG51bWJlciwgc3RhdHVzOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wdXQoYC9qb3VybmFscy8ke2pvdXJuYWxJZH0vc3RhdHVzYCwgeyBzdGF0dXMgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG4gIFxuICBwdWJsaXNoSm91cm5hbDogYXN5bmMgKGpvdXJuYWxJZDogbnVtYmVyLCBwdWJsaWNhdGlvbk51bWJlcjogc3RyaW5nKSA9PiB7XG4gICAgLy8gVXNlIHB1YmxpY2F0aW9uX251bWJlciB0byBtYXRjaCB0aGUgYmFja2VuZCdzIGV4cGVjdGVkIHBhcmFtZXRlciBuYW1lXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucHV0KGAvam91cm5hbHMvJHtqb3VybmFsSWR9L3B1Ymxpc2hgLCB7IHB1YmxpY2F0aW9uX251bWJlcjogcHVibGljYXRpb25OdW1iZXIgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG4gIHVucHVibGlzaEpvdXJuYWw6IGFzeW5jIChqb3VybmFsSWQ6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnB1dChgL2pvdXJuYWxzLyR7am91cm5hbElkfS91bnB1Ymxpc2hgKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcbn07XG5cbi8vIFJldmlldyBBUElcbmV4cG9ydCBjb25zdCByZXZpZXdBUEkgPSB7XG4gIGdldEpvdXJuYWxSZXZpZXdzOiBhc3luYyAoam91cm5hbElkOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoYC9yZXZpZXdzL2pvdXJuYWwvJHtqb3VybmFsSWR9YCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG5cbiAgZ2V0QXNzaWduZWRSZXZpZXdzOiBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KCcvcmV2aWV3cy9hc3NpZ25lZCcpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgYXBpO1xuIl0sIm5hbWVzIjpbImF4aW9zIiwiaXNCcm93c2VyIiwiZ2V0QXBpQmFzZVVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiQkFDS0VORF9VUkwiLCJjb25zb2xlIiwibG9nIiwiYXBpIiwiY3JlYXRlIiwiYmFzZVVSTCIsImhlYWRlcnMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJpbnRlcmNlcHRvcnMiLCJyZXF1ZXN0IiwidXNlIiwiY29uZmlnIiwidG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiQXV0aG9yaXphdGlvbiIsInVybCIsImVycm9yIiwiUHJvbWlzZSIsInJlamVjdCIsImF1dGhBUEkiLCJyZWdpc3RlciIsImZvcm1EYXRhIiwicmVzcG9uc2UiLCJwb3N0IiwiZGF0YSIsInZlcmlmeUVtYWlsIiwiZW1haWwiLCJvdHAiLCJyZXNlbmRPVFAiLCJsb2dpbiIsInBhc3N3b3JkIiwiZ2V0UHJvZmlsZSIsImdldCIsImNoYW5nZVBhc3N3b3JkIiwiY3VycmVudFBhc3N3b3JkIiwibmV3UGFzc3dvcmQiLCJwdXQiLCJyZXNldFBhc3N3b3JkIiwidXNlcklkIiwiZm9yZ290UGFzc3dvcmQiLCJ2ZXJpZnlSZXNldFRva2VuIiwicmVzZXRQYXNzd29yZFdpdGhUb2tlbiIsInVzZXJBUEkiLCJnZXRBbGxVc2VycyIsInJvbGUiLCJwYXJhbXMiLCJnZXRVc2VyQnlJZCIsImlkIiwiY3JlYXRlVXNlciIsInVzZXJEYXRhIiwidXBkYXRlVXNlciIsImRlbGV0ZVVzZXIiLCJkZWxldGUiLCJqb3VybmFsQVBJIiwiZ2V0UHVibGlzaGVkSm91cm5hbHMiLCJmaWx0ZXJzIiwic29ydF9ieSIsInNvcnRfb3JkZXIiLCJzZWFyY2giLCJsaW1pdCIsInBhZ2UiLCJfdCIsIkRhdGUiLCJnZXRUaW1lIiwiY3JlYXRlSm91cm5hbCIsImdldEFsbEpvdXJuYWxzIiwiZ2V0Sm91cm5hbEJ5SWQiLCJnZXRBbGxSZXZpZXdlcnMiLCJhc3NpZ25SZXZpZXdlciIsImpvdXJuYWxJZCIsInJldmlld2VySWQiLCJyZXZpZXdlcl9pZCIsInJldmlld0pvdXJuYWwiLCJzdGF0dXMiLCJjb21tZW50cyIsImdldEpvdXJuYWxGaWxlIiwiZG93bmxvYWRKb3VybmFsIiwiam91cm5hbCIsImZpbGVJbmZvIiwiZG93bmxvYWRVcmwiLCJ3aW5kb3ciLCJvcGVuIiwiYSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwiZGlzcGxheSIsImFwaUJhc2VVcmwiLCJyZXBsYWNlIiwiaHJlZiIsImluY2x1ZGVzIiwiYm9keSIsImFwcGVuZENoaWxkIiwiY2xpY2siLCJyZW1vdmVDaGlsZCIsImRlbGV0ZUpvdXJuYWwiLCJ1cGRhdGVKb3VybmFsU3RhdHVzIiwicHVibGlzaEpvdXJuYWwiLCJwdWJsaWNhdGlvbk51bWJlciIsInB1YmxpY2F0aW9uX251bWJlciIsInVucHVibGlzaEpvdXJuYWwiLCJyZXZpZXdBUEkiLCJnZXRKb3VybmFsUmV2aWV3cyIsImdldEFzc2lnbmVkUmV2aWV3cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/utils/api.ts\n"));

/***/ })

});