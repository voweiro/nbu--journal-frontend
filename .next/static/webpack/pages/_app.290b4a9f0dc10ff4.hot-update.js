"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/utils/api.ts":
/*!**************************!*\
  !*** ./src/utils/api.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authAPI: function() { return /* binding */ authAPI; },\n/* harmony export */   journalAPI: function() { return /* binding */ journalAPI; },\n/* harmony export */   reviewAPI: function() { return /* binding */ reviewAPI; },\n/* harmony export */   userAPI: function() { return /* binding */ userAPI; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ \"./src/utils/config.ts\");\n\n// Check if code is running in browser environment\nconst isBrowser = \"object\" !== \"undefined\";\n// IMPORTANT: Hard-coded backend URL to avoid any caching issues\nconst BACKEND_URL = \"https://nbu-journal-backend.onrender.com/api\";\n// Create axios instance with the fixed backend URL\nconst api = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: BACKEND_URL,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n    withCredentials: true\n});\nconsole.log(\"API configured with URL:\", BACKEND_URL);\n// Add auth token to requests if available\napi.interceptors.request.use((config)=>{\n    // Only try to get token from localStorage in browser environment\n    if (isBrowser) {\n        const token = localStorage.getItem(\"token\");\n        if (token) {\n            config.headers.Authorization = \"Bearer \".concat(token);\n        }\n    }\n    console.log(\"Making request to:\", config.url, \"with baseURL:\", config.baseURL);\n    return config;\n}, (error)=>Promise.reject(error));\n\n// Auth API\nconst authAPI = {\n    register: async (formData)=>{\n        const response = await api.post(\"/auth/register\", formData, {\n            headers: {\n                \"Content-Type\": \"multipart/form-data\"\n            }\n        });\n        return response.data;\n    },\n    verifyEmail: async (email, otp)=>{\n        const response = await api.post(\"/auth/verify-email\", {\n            email,\n            otp\n        });\n        return response.data;\n    },\n    resendOTP: async (email)=>{\n        const response = await api.post(\"/auth/resend-otp\", {\n            email\n        });\n        return response.data;\n    },\n    login: async (email, password)=>{\n        const response = await api.post(\"/auth/login\", {\n            email,\n            password\n        });\n        return response.data;\n    },\n    getProfile: async ()=>{\n        const response = await api.get(\"/auth/profile\");\n        return response.data;\n    },\n    changePassword: async (currentPassword, newPassword)=>{\n        const response = await api.put(\"/auth/change-password\", {\n            currentPassword,\n            newPassword\n        });\n        return response.data;\n    },\n    resetPassword: async (userId, newPassword)=>{\n        const response = await api.put(\"/auth/reset-password\", {\n            userId,\n            newPassword\n        });\n        return response.data;\n    },\n    forgotPassword: async (email)=>{\n        // Generate the correct password reset URL for the frontend\n        const resetUrl = (0,_config__WEBPACK_IMPORTED_MODULE_1__.getPasswordResetUrl)(email, \"TOKEN_PLACEHOLDER\");\n        const baseResetUrl = resetUrl.replace(\"TOKEN_PLACEHOLDER\", \"\");\n        console.log(\"Sending password reset request with URL template:\", baseResetUrl);\n        // Send the base URL to the backend so it can generate the correct link\n        const response = await api.post(\"/auth/forgot-password\", {\n            email,\n            reset_url_template: baseResetUrl\n        });\n        return response.data;\n    },\n    verifyResetToken: async (email, token)=>{\n        const response = await api.post(\"/auth/verify-reset-token\", {\n            email,\n            token\n        });\n        return response.data;\n    },\n    resetPasswordWithToken: async (email, token, password)=>{\n        const response = await api.post(\"/auth/reset-password-with-token\", {\n            email,\n            token,\n            password\n        });\n        return response.data;\n    }\n};\n// User API\nconst userAPI = {\n    getAllUsers: async (role)=>{\n        const response = await api.get(\"/users\", {\n            params: {\n                role\n            }\n        });\n        return response.data;\n    },\n    getUserById: async (id)=>{\n        const response = await api.get(\"/users/\".concat(id));\n        return response.data;\n    },\n    createUser: async (userData)=>{\n        const response = await api.post(\"/users\", userData);\n        return response.data;\n    },\n    updateUser: async (id, formData)=>{\n        const response = await api.put(\"/users/\".concat(id), formData, {\n            headers: {\n                \"Content-Type\": \"multipart/form-data\"\n            }\n        });\n        return response.data;\n    },\n    deleteUser: async (id)=>{\n        const response = await api.delete(\"/users/\".concat(id));\n        return response.data;\n    },\n    resetPassword: async (userId, newPassword)=>{\n        const response = await api.post(\"/auth/reset-password\", {\n            userId,\n            newPassword\n        });\n        return response.data;\n    }\n};\n// Journal API\nconst journalAPI = {\n    getPublishedJournals: async function() {\n        let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        // Use params object instead of manually constructing URL\n        const response = await api.get(\"/journals/published\", {\n            params: {\n                sort_by: filters.sort_by || \"published_date\",\n                sort_order: filters.sort_order || \"DESC\",\n                search: filters.search || \"\",\n                limit: filters.limit || null,\n                page: filters.page || null,\n                _t: new Date().getTime() // Cache-busting parameter\n            }\n        });\n        console.log(\"API response for published journals:\", response.data);\n        return response.data;\n    },\n    createJournal: async (formData)=>{\n        const response = await api.post(\"/journals\", formData, {\n            headers: {\n                \"Content-Type\": \"multipart/form-data\"\n            }\n        });\n        return response.data;\n    },\n    getAllJournals: async (filters)=>{\n        const response = await api.get(\"/journals\", {\n            params: filters\n        });\n        return response.data;\n    },\n    getJournalById: async (id)=>{\n        try {\n            // First try to get the journal as a published journal (no auth required)\n            const response = await api.get(\"/journals/published/\".concat(id));\n            return response.data;\n        } catch (error) {\n            // If that fails (e.g., journal is not published), fall back to the authenticated route\n            const response = await api.get(\"/journals/\".concat(id));\n            return response.data;\n        }\n    },\n    getAllReviewers: async ()=>{\n        const response = await api.get(\"/journals/reviewers\");\n        return response.data;\n    },\n    assignReviewer: async (journalId, reviewerId)=>{\n        const response = await api.put(\"/journals/\".concat(journalId, \"/assign\"), {\n            reviewer_id: reviewerId\n        });\n        return response.data;\n    },\n    reviewJournal: async (journalId, status, comments)=>{\n        const response = await api.put(\"/journals/\".concat(journalId, \"/review\"), {\n            status,\n            comments\n        });\n        return response.data;\n    },\n    getJournalFile: async (journalId)=>{\n        const response = await api.get(\"/journals/\".concat(journalId, \"/file\"));\n        return response.data;\n    },\n    downloadJournal: async (journalId)=>{\n        try {\n            // First try to get the journal to check if it's published\n            const { journal } = await journalAPI.getJournalById(journalId);\n            // For published journals, try to get file info from the public endpoint\n            let fileInfo;\n            try {\n                // For published journals, we can try the public endpoint first\n                if (journal.status === \"published\") {\n                    // Try to get file info from the public endpoint\n                    const response = await api.get(\"/journals/published/\".concat(journalId, \"/file\"));\n                    fileInfo = response.data;\n                } else {\n                    // For non-published journals, use the authenticated endpoint\n                    fileInfo = await journalAPI.getJournalFile(journalId);\n                }\n            } catch (error) {\n                console.log(\"Could not get file info, proceeding with direct download\", error);\n            }\n            // If we have Google Drive file info with a download URL, use that\n            if (fileInfo && fileInfo.downloadUrl) {\n                console.log(\"Using Google Drive download URL:\", fileInfo.downloadUrl);\n                window.open(fileInfo.downloadUrl, \"_blank\");\n                return;\n            }\n            // If Google Drive info is not available, try direct download\n            console.log(\"Falling back to direct download\");\n            // Create a temporary hidden anchor element\n            const a = document.createElement(\"a\");\n            a.style.display = \"none\";\n            // Use the hardcoded backend URL to avoid any caching issues\n            const apiBaseUrl = BACKEND_URL.replace(\"/api\", \"\");\n            // Use the public route for published journals, otherwise use the authenticated route\n            if (journal.status === \"published\") {\n                a.href = \"\".concat(apiBaseUrl, \"/api/journals/published/\").concat(journalId, \"/download\");\n                // Try alternative path if API base URL doesn't include /api\n                if (!apiBaseUrl.includes(\"/api\")) {\n                    a.href = \"\".concat(apiBaseUrl, \"/journals/published/\").concat(journalId, \"/download\");\n                }\n            } else {\n                // Fallback to the authenticated route\n                const token = localStorage.getItem(\"token\");\n                a.href = \"\".concat(apiBaseUrl, \"/api/journals/\").concat(journalId, \"/download\");\n                // Try alternative path if API base URL doesn't include /api\n                if (!apiBaseUrl.includes(\"/api\")) {\n                    a.href = \"\".concat(apiBaseUrl, \"/journals/\").concat(journalId, \"/download\");\n                }\n                // Add the token as a query parameter\n                if (token) {\n                    a.href += \"?token=\".concat(token);\n                }\n            }\n            console.log(\"Download URL:\", a.href);\n            // Append to body, click, and remove\n            document.body.appendChild(a);\n            a.click();\n            document.body.removeChild(a);\n        } catch (error) {\n            console.error(\"Error downloading journal:\", error);\n        }\n    },\n    deleteJournal: async (journalId)=>{\n        const response = await api.delete(\"/journals/\".concat(journalId));\n        return response.data;\n    },\n    updateJournalStatus: async (journalId, status)=>{\n        const response = await api.put(\"/journals/\".concat(journalId, \"/status\"), {\n            status\n        });\n        return response.data;\n    },\n    publishJournal: async (journalId, publicationNumber)=>{\n        // Use publication_number to match the backend's expected parameter name\n        const response = await api.put(\"/journals/\".concat(journalId, \"/publish\"), {\n            publication_number: publicationNumber\n        });\n        return response.data;\n    },\n    unpublishJournal: async (journalId)=>{\n        // When unpublishing, set the status back to 'approved' since that's the state before publishing\n        const response = await api.put(\"/journals/\".concat(journalId, \"/unpublish\"), {\n            status: \"approved\"\n        });\n        return response.data;\n    }\n};\n// Review API\nconst reviewAPI = {\n    getJournalReviews: async (journalId)=>{\n        const response = await api.get(\"/reviews/journal/\".concat(journalId));\n        return response.data;\n    },\n    getAssignedReviews: async ()=>{\n        const response = await api.get(\"/reviews/assigned\");\n        return response.data;\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (api);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QztRQUMvQixPQUFPVixTQUFTRSxJQUFJO0lBQ3RCO0FBQ0YsRUFBRTtBQUVGLCtEQUFlekIsR0FBR0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvdXRpbHMvYXBpLnRzP2I5NzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCB7IFVzZXIsIEpvdXJuYWwsIEpvdXJuYWxTdGF0dXMsIEpvdXJuYWxGaWx0ZXJzIH0gZnJvbSAnQC90eXBlcyc7XG5cbi8vIENoZWNrIGlmIGNvZGUgaXMgcnVubmluZyBpbiBicm93c2VyIGVudmlyb25tZW50XG5jb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxuLy8gSU1QT1JUQU5UOiBIYXJkLWNvZGVkIGJhY2tlbmQgVVJMIHRvIGF2b2lkIGFueSBjYWNoaW5nIGlzc3Vlc1xuY29uc3QgQkFDS0VORF9VUkwgPSAnaHR0cHM6Ly9uYnUtam91cm5hbC1iYWNrZW5kLm9ucmVuZGVyLmNvbS9hcGknO1xuXG4vLyBDcmVhdGUgYXhpb3MgaW5zdGFuY2Ugd2l0aCB0aGUgZml4ZWQgYmFja2VuZCBVUkxcbmNvbnN0IGFwaSA9IGF4aW9zLmNyZWF0ZSh7XG4gIGJhc2VVUkw6IEJBQ0tFTkRfVVJMLFxuICBoZWFkZXJzOiB7XG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgfSxcbiAgd2l0aENyZWRlbnRpYWxzOiB0cnVlLCAvLyBJbXBvcnRhbnQgZm9yIGNvb2tpZXMvYXV0aCBpZiBuZWVkZWRcbn0pO1xuXG5jb25zb2xlLmxvZygnQVBJIGNvbmZpZ3VyZWQgd2l0aCBVUkw6JywgQkFDS0VORF9VUkwpO1xuXG4vLyBBZGQgYXV0aCB0b2tlbiB0byByZXF1ZXN0cyBpZiBhdmFpbGFibGVcbmFwaS5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoXG4gIChjb25maWcpID0+IHtcbiAgICAvLyBPbmx5IHRyeSB0byBnZXQgdG9rZW4gZnJvbSBsb2NhbFN0b3JhZ2UgaW4gYnJvd3NlciBlbnZpcm9ubWVudFxuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3Rva2VuJyk7XG4gICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgY29uZmlnLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGBCZWFyZXIgJHt0b2tlbn1gO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zb2xlLmxvZygnTWFraW5nIHJlcXVlc3QgdG86JywgY29uZmlnLnVybCwgJ3dpdGggYmFzZVVSTDonLCBjb25maWcuYmFzZVVSTCk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfSxcbiAgKGVycm9yKSA9PiBQcm9taXNlLnJlamVjdChlcnJvcilcbik7XG5cbmltcG9ydCB7IGdldFBhc3N3b3JkUmVzZXRVcmwgfSBmcm9tICcuL2NvbmZpZyc7XG5cbi8vIEF1dGggQVBJXG5leHBvcnQgY29uc3QgYXV0aEFQSSA9IHtcbiAgcmVnaXN0ZXI6IGFzeW5jIChmb3JtRGF0YTogRm9ybURhdGEpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvYXV0aC9yZWdpc3RlcicsIGZvcm1EYXRhLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIHZlcmlmeUVtYWlsOiBhc3luYyAoZW1haWw6IHN0cmluZywgb3RwOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvYXV0aC92ZXJpZnktZW1haWwnLCB7IGVtYWlsLCBvdHAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG5cbiAgcmVzZW5kT1RQOiBhc3luYyAoZW1haWw6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9hdXRoL3Jlc2VuZC1vdHAnLCB7IGVtYWlsIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIGxvZ2luOiBhc3luYyAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9hdXRoL2xvZ2luJywgeyBlbWFpbCwgcGFzc3dvcmQgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG5cbiAgZ2V0UHJvZmlsZTogYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL2F1dGgvcHJvZmlsZScpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIGNoYW5nZVBhc3N3b3JkOiBhc3luYyAoY3VycmVudFBhc3N3b3JkOiBzdHJpbmcsIG5ld1Bhc3N3b3JkOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wdXQoJy9hdXRoL2NoYW5nZS1wYXNzd29yZCcsIHtcbiAgICAgIGN1cnJlbnRQYXNzd29yZCxcbiAgICAgIG5ld1Bhc3N3b3JkLFxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIHJlc2V0UGFzc3dvcmQ6IGFzeW5jICh1c2VySWQ6IG51bWJlciwgbmV3UGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnB1dCgnL2F1dGgvcmVzZXQtcGFzc3dvcmQnLCB7XG4gICAgICB1c2VySWQsXG4gICAgICBuZXdQYXNzd29yZCxcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcblxuICBmb3Jnb3RQYXNzd29yZDogYXN5bmMgKGVtYWlsOiBzdHJpbmcpID0+IHtcbiAgICAvLyBHZW5lcmF0ZSB0aGUgY29ycmVjdCBwYXNzd29yZCByZXNldCBVUkwgZm9yIHRoZSBmcm9udGVuZFxuICAgIGNvbnN0IHJlc2V0VXJsID0gZ2V0UGFzc3dvcmRSZXNldFVybChlbWFpbCwgJ1RPS0VOX1BMQUNFSE9MREVSJyk7XG4gICAgY29uc3QgYmFzZVJlc2V0VXJsID0gcmVzZXRVcmwucmVwbGFjZSgnVE9LRU5fUExBQ0VIT0xERVInLCAnJyk7XG5cbiAgICBjb25zb2xlLmxvZygnU2VuZGluZyBwYXNzd29yZCByZXNldCByZXF1ZXN0IHdpdGggVVJMIHRlbXBsYXRlOicsIGJhc2VSZXNldFVybCk7XG5cbiAgICAvLyBTZW5kIHRoZSBiYXNlIFVSTCB0byB0aGUgYmFja2VuZCBzbyBpdCBjYW4gZ2VuZXJhdGUgdGhlIGNvcnJlY3QgbGlua1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9hdXRoL2ZvcmdvdC1wYXNzd29yZCcsIHsgXG4gICAgICBlbWFpbCxcbiAgICAgIHJlc2V0X3VybF90ZW1wbGF0ZTogYmFzZVJlc2V0VXJsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcblxuICB2ZXJpZnlSZXNldFRva2VuOiBhc3luYyAoZW1haWw6IHN0cmluZywgdG9rZW46IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9hdXRoL3ZlcmlmeS1yZXNldC10b2tlbicsIHsgZW1haWwsIHRva2VuIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIHJlc2V0UGFzc3dvcmRXaXRoVG9rZW46IGFzeW5jIChlbWFpbDogc3RyaW5nLCB0b2tlbjogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdCgnL2F1dGgvcmVzZXQtcGFzc3dvcmQtd2l0aC10b2tlbicsIHsgZW1haWwsIHRva2VuLCBwYXNzd29yZCB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcbn07XG5cbi8vIFVzZXIgQVBJXG5leHBvcnQgY29uc3QgdXNlckFQSSA9IHtcbiAgZ2V0QWxsVXNlcnM6IGFzeW5jIChyb2xlPzogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KCcvdXNlcnMnLCB7XG4gICAgICBwYXJhbXM6IHsgcm9sZSB9LFxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIGdldFVzZXJCeUlkOiBhc3luYyAoaWQ6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldChgL3VzZXJzLyR7aWR9YCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG5cbiAgY3JlYXRlVXNlcjogYXN5bmMgKHVzZXJEYXRhOiB7XG4gICAgdXNlcm5hbWU6IHN0cmluZztcbiAgICBlbWFpbDogc3RyaW5nO1xuICAgIHBhc3N3b3JkOiBzdHJpbmc7XG4gICAgZmlyc3RfbmFtZTogc3RyaW5nO1xuICAgIGxhc3RfbmFtZTogc3RyaW5nO1xuICAgIHJvbGU6IHN0cmluZztcbiAgICBkZXBhcnRtZW50Pzogc3RyaW5nO1xuICB9KSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdCgnL3VzZXJzJywgdXNlckRhdGEpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIHVwZGF0ZVVzZXI6IGFzeW5jIChpZDogbnVtYmVyLCBmb3JtRGF0YTogRm9ybURhdGEpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wdXQoYC91c2Vycy8ke2lkfWAsIGZvcm1EYXRhLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIGRlbGV0ZVVzZXI6IGFzeW5jIChpZDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZGVsZXRlKGAvdXNlcnMvJHtpZH1gKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcblxuICByZXNldFBhc3N3b3JkOiBhc3luYyAodXNlcklkOiBudW1iZXIsIG5ld1Bhc3N3b3JkOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KGAvYXV0aC9yZXNldC1wYXNzd29yZGAsIHsgdXNlcklkLCBuZXdQYXNzd29yZCB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcbn07XG5cbi8vIEpvdXJuYWwgQVBJXG5leHBvcnQgY29uc3Qgam91cm5hbEFQSSA9IHtcbiAgZ2V0UHVibGlzaGVkSm91cm5hbHM6IGFzeW5jIChmaWx0ZXJzOiBKb3VybmFsRmlsdGVycyA9IHt9KSA9PiB7XG4gICAgLy8gVXNlIHBhcmFtcyBvYmplY3QgaW5zdGVhZCBvZiBtYW51YWxseSBjb25zdHJ1Y3RpbmcgVVJMXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KCcvam91cm5hbHMvcHVibGlzaGVkJywge1xuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHNvcnRfYnk6IGZpbHRlcnMuc29ydF9ieSB8fCAncHVibGlzaGVkX2RhdGUnLFxuICAgICAgICBzb3J0X29yZGVyOiBmaWx0ZXJzLnNvcnRfb3JkZXIgfHwgJ0RFU0MnLFxuICAgICAgICBzZWFyY2g6IGZpbHRlcnMuc2VhcmNoIHx8ICcnLFxuICAgICAgICBsaW1pdDogZmlsdGVycy5saW1pdCB8fCBudWxsLFxuICAgICAgICBwYWdlOiBmaWx0ZXJzLnBhZ2UgfHwgbnVsbCxcbiAgICAgICAgX3Q6IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8vIENhY2hlLWJ1c3RpbmcgcGFyYW1ldGVyXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc29sZS5sb2coJ0FQSSByZXNwb25zZSBmb3IgcHVibGlzaGVkIGpvdXJuYWxzOicsIHJlc3BvbnNlLmRhdGEpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuICBcbiAgY3JlYXRlSm91cm5hbDogYXN5bmMgKGZvcm1EYXRhOiBGb3JtRGF0YSkgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9qb3VybmFscycsIGZvcm1EYXRhLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIGdldEFsbEpvdXJuYWxzOiBhc3luYyAoZmlsdGVycz86IEpvdXJuYWxGaWx0ZXJzKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KCcvam91cm5hbHMnLCB7XG4gICAgICBwYXJhbXM6IGZpbHRlcnMsXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG5cbiAgZ2V0Sm91cm5hbEJ5SWQ6IGFzeW5jIChpZDogbnVtYmVyKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpcnN0IHRyeSB0byBnZXQgdGhlIGpvdXJuYWwgYXMgYSBwdWJsaXNoZWQgam91cm5hbCAobm8gYXV0aCByZXF1aXJlZClcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldChgL2pvdXJuYWxzL3B1Ymxpc2hlZC8ke2lkfWApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElmIHRoYXQgZmFpbHMgKGUuZy4sIGpvdXJuYWwgaXMgbm90IHB1Ymxpc2hlZCksIGZhbGwgYmFjayB0byB0aGUgYXV0aGVudGljYXRlZCByb3V0ZVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KGAvam91cm5hbHMvJHtpZH1gKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgfSxcblxuICBnZXRBbGxSZXZpZXdlcnM6IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoJy9qb3VybmFscy9yZXZpZXdlcnMnKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcblxuICBhc3NpZ25SZXZpZXdlcjogYXN5bmMgKGpvdXJuYWxJZDogbnVtYmVyLCByZXZpZXdlcklkOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wdXQoYC9qb3VybmFscy8ke2pvdXJuYWxJZH0vYXNzaWduYCwge1xuICAgICAgcmV2aWV3ZXJfaWQ6IHJldmlld2VySWQsXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG5cbiAgcmV2aWV3Sm91cm5hbDogYXN5bmMgKGpvdXJuYWxJZDogbnVtYmVyLCBzdGF0dXM6ICdhcHByb3ZlZCcgfCAncmVqZWN0ZWQnLCBjb21tZW50czogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucHV0KGAvam91cm5hbHMvJHtqb3VybmFsSWR9L3Jldmlld2AsIHtcbiAgICAgIHN0YXR1cyxcbiAgICAgIGNvbW1lbnRzLFxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIGdldEpvdXJuYWxGaWxlOiBhc3luYyAoam91cm5hbElkOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoYC9qb3VybmFscy8ke2pvdXJuYWxJZH0vZmlsZWApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuICBcbiAgZG93bmxvYWRKb3VybmFsOiBhc3luYyAoam91cm5hbElkOiBudW1iZXIpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gRmlyc3QgdHJ5IHRvIGdldCB0aGUgam91cm5hbCB0byBjaGVjayBpZiBpdCdzIHB1Ymxpc2hlZFxuICAgICAgY29uc3QgeyBqb3VybmFsIH0gPSBhd2FpdCBqb3VybmFsQVBJLmdldEpvdXJuYWxCeUlkKGpvdXJuYWxJZCk7XG4gICAgICBcbiAgICAgIC8vIEZvciBwdWJsaXNoZWQgam91cm5hbHMsIHRyeSB0byBnZXQgZmlsZSBpbmZvIGZyb20gdGhlIHB1YmxpYyBlbmRwb2ludFxuICAgICAgbGV0IGZpbGVJbmZvO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRm9yIHB1Ymxpc2hlZCBqb3VybmFscywgd2UgY2FuIHRyeSB0aGUgcHVibGljIGVuZHBvaW50IGZpcnN0XG4gICAgICAgIGlmIChqb3VybmFsLnN0YXR1cyA9PT0gJ3B1Ymxpc2hlZCcpIHtcbiAgICAgICAgICAvLyBUcnkgdG8gZ2V0IGZpbGUgaW5mbyBmcm9tIHRoZSBwdWJsaWMgZW5kcG9pbnRcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoYC9qb3VybmFscy9wdWJsaXNoZWQvJHtqb3VybmFsSWR9L2ZpbGVgKTtcbiAgICAgICAgICBmaWxlSW5mbyA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRm9yIG5vbi1wdWJsaXNoZWQgam91cm5hbHMsIHVzZSB0aGUgYXV0aGVudGljYXRlZCBlbmRwb2ludFxuICAgICAgICAgIGZpbGVJbmZvID0gYXdhaXQgam91cm5hbEFQSS5nZXRKb3VybmFsRmlsZShqb3VybmFsSWQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZygnQ291bGQgbm90IGdldCBmaWxlIGluZm8sIHByb2NlZWRpbmcgd2l0aCBkaXJlY3QgZG93bmxvYWQnLCBlcnJvcik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIHdlIGhhdmUgR29vZ2xlIERyaXZlIGZpbGUgaW5mbyB3aXRoIGEgZG93bmxvYWQgVVJMLCB1c2UgdGhhdFxuICAgICAgaWYgKGZpbGVJbmZvICYmIGZpbGVJbmZvLmRvd25sb2FkVXJsKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBHb29nbGUgRHJpdmUgZG93bmxvYWQgVVJMOicsIGZpbGVJbmZvLmRvd25sb2FkVXJsKTtcbiAgICAgICAgd2luZG93Lm9wZW4oZmlsZUluZm8uZG93bmxvYWRVcmwsICdfYmxhbmsnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiBHb29nbGUgRHJpdmUgaW5mbyBpcyBub3QgYXZhaWxhYmxlLCB0cnkgZGlyZWN0IGRvd25sb2FkXG4gICAgICBjb25zb2xlLmxvZygnRmFsbGluZyBiYWNrIHRvIGRpcmVjdCBkb3dubG9hZCcpO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgaGlkZGVuIGFuY2hvciBlbGVtZW50XG4gICAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgYS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgXG4gICAgICAvLyBVc2UgdGhlIGhhcmRjb2RlZCBiYWNrZW5kIFVSTCB0byBhdm9pZCBhbnkgY2FjaGluZyBpc3N1ZXNcbiAgICAgIGNvbnN0IGFwaUJhc2VVcmwgPSBCQUNLRU5EX1VSTC5yZXBsYWNlKCcvYXBpJywgJycpO1xuICAgICAgXG4gICAgICAvLyBVc2UgdGhlIHB1YmxpYyByb3V0ZSBmb3IgcHVibGlzaGVkIGpvdXJuYWxzLCBvdGhlcndpc2UgdXNlIHRoZSBhdXRoZW50aWNhdGVkIHJvdXRlXG4gICAgICBpZiAoam91cm5hbC5zdGF0dXMgPT09ICdwdWJsaXNoZWQnKSB7XG4gICAgICAgIGEuaHJlZiA9IGAke2FwaUJhc2VVcmx9L2FwaS9qb3VybmFscy9wdWJsaXNoZWQvJHtqb3VybmFsSWR9L2Rvd25sb2FkYDtcbiAgICAgICAgLy8gVHJ5IGFsdGVybmF0aXZlIHBhdGggaWYgQVBJIGJhc2UgVVJMIGRvZXNuJ3QgaW5jbHVkZSAvYXBpXG4gICAgICAgIGlmICghYXBpQmFzZVVybC5pbmNsdWRlcygnL2FwaScpKSB7XG4gICAgICAgICAgYS5ocmVmID0gYCR7YXBpQmFzZVVybH0vam91cm5hbHMvcHVibGlzaGVkLyR7am91cm5hbElkfS9kb3dubG9hZGA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIHRoZSBhdXRoZW50aWNhdGVkIHJvdXRlXG4gICAgICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3Rva2VuJyk7XG4gICAgICAgIGEuaHJlZiA9IGAke2FwaUJhc2VVcmx9L2FwaS9qb3VybmFscy8ke2pvdXJuYWxJZH0vZG93bmxvYWRgO1xuICAgICAgICAvLyBUcnkgYWx0ZXJuYXRpdmUgcGF0aCBpZiBBUEkgYmFzZSBVUkwgZG9lc24ndCBpbmNsdWRlIC9hcGlcbiAgICAgICAgaWYgKCFhcGlCYXNlVXJsLmluY2x1ZGVzKCcvYXBpJykpIHtcbiAgICAgICAgICBhLmhyZWYgPSBgJHthcGlCYXNlVXJsfS9qb3VybmFscy8ke2pvdXJuYWxJZH0vZG93bmxvYWRgO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgdGhlIHRva2VuIGFzIGEgcXVlcnkgcGFyYW1ldGVyXG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgIGEuaHJlZiArPSBgP3Rva2VuPSR7dG9rZW59YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnRG93bmxvYWQgVVJMOicsIGEuaHJlZik7XG4gICAgICBcbiAgICAgIC8vIEFwcGVuZCB0byBib2R5LCBjbGljaywgYW5kIHJlbW92ZVxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKTtcbiAgICAgIGEuY2xpY2soKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoYSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRvd25sb2FkaW5nIGpvdXJuYWw6JywgZXJyb3IpO1xuICAgIH1cbiAgfSxcbiAgXG4gIGRlbGV0ZUpvdXJuYWw6IGFzeW5jIChqb3VybmFsSWQ6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmRlbGV0ZShgL2pvdXJuYWxzLyR7am91cm5hbElkfWApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuICBcbiAgdXBkYXRlSm91cm5hbFN0YXR1czogYXN5bmMgKGpvdXJuYWxJZDogbnVtYmVyLCBzdGF0dXM6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnB1dChgL2pvdXJuYWxzLyR7am91cm5hbElkfS9zdGF0dXNgLCB7IHN0YXR1cyB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcbiAgXG4gIHB1Ymxpc2hKb3VybmFsOiBhc3luYyAoam91cm5hbElkOiBudW1iZXIsIHB1YmxpY2F0aW9uTnVtYmVyOiBzdHJpbmcpID0+IHtcbiAgICAvLyBVc2UgcHVibGljYXRpb25fbnVtYmVyIHRvIG1hdGNoIHRoZSBiYWNrZW5kJ3MgZXhwZWN0ZWQgcGFyYW1ldGVyIG5hbWVcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wdXQoYC9qb3VybmFscy8ke2pvdXJuYWxJZH0vcHVibGlzaGAsIHsgcHVibGljYXRpb25fbnVtYmVyOiBwdWJsaWNhdGlvbk51bWJlciB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcbiAgdW5wdWJsaXNoSm91cm5hbDogYXN5bmMgKGpvdXJuYWxJZDogbnVtYmVyKSA9PiB7XG4gICAgLy8gV2hlbiB1bnB1Ymxpc2hpbmcsIHNldCB0aGUgc3RhdHVzIGJhY2sgdG8gJ2FwcHJvdmVkJyBzaW5jZSB0aGF0J3MgdGhlIHN0YXRlIGJlZm9yZSBwdWJsaXNoaW5nXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucHV0KGAvam91cm5hbHMvJHtqb3VybmFsSWR9L3VucHVibGlzaGAsIHsgc3RhdHVzOiAnYXBwcm92ZWQnIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxufTtcblxuLy8gUmV2aWV3IEFQSVxuZXhwb3J0IGNvbnN0IHJldmlld0FQSSA9IHtcbiAgZ2V0Sm91cm5hbFJldmlld3M6IGFzeW5jIChqb3VybmFsSWQ6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldChgL3Jldmlld3Mvam91cm5hbC8ke2pvdXJuYWxJZH1gKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcblxuICBnZXRBc3NpZ25lZFJldmlld3M6IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoJy9yZXZpZXdzL2Fzc2lnbmVkJyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBhcGk7XG4iXSwibmFtZXMiOlsiYXhpb3MiLCJpc0Jyb3dzZXIiLCJCQUNLRU5EX1VSTCIsImFwaSIsImNyZWF0ZSIsImJhc2VVUkwiLCJoZWFkZXJzIiwid2l0aENyZWRlbnRpYWxzIiwiY29uc29sZSIsImxvZyIsImludGVyY2VwdG9ycyIsInJlcXVlc3QiLCJ1c2UiLCJjb25maWciLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJBdXRob3JpemF0aW9uIiwidXJsIiwiZXJyb3IiLCJQcm9taXNlIiwicmVqZWN0IiwiZ2V0UGFzc3dvcmRSZXNldFVybCIsImF1dGhBUEkiLCJyZWdpc3RlciIsImZvcm1EYXRhIiwicmVzcG9uc2UiLCJwb3N0IiwiZGF0YSIsInZlcmlmeUVtYWlsIiwiZW1haWwiLCJvdHAiLCJyZXNlbmRPVFAiLCJsb2dpbiIsInBhc3N3b3JkIiwiZ2V0UHJvZmlsZSIsImdldCIsImNoYW5nZVBhc3N3b3JkIiwiY3VycmVudFBhc3N3b3JkIiwibmV3UGFzc3dvcmQiLCJwdXQiLCJyZXNldFBhc3N3b3JkIiwidXNlcklkIiwiZm9yZ290UGFzc3dvcmQiLCJyZXNldFVybCIsImJhc2VSZXNldFVybCIsInJlcGxhY2UiLCJyZXNldF91cmxfdGVtcGxhdGUiLCJ2ZXJpZnlSZXNldFRva2VuIiwicmVzZXRQYXNzd29yZFdpdGhUb2tlbiIsInVzZXJBUEkiLCJnZXRBbGxVc2VycyIsInJvbGUiLCJwYXJhbXMiLCJnZXRVc2VyQnlJZCIsImlkIiwiY3JlYXRlVXNlciIsInVzZXJEYXRhIiwidXBkYXRlVXNlciIsImRlbGV0ZVVzZXIiLCJkZWxldGUiLCJqb3VybmFsQVBJIiwiZ2V0UHVibGlzaGVkSm91cm5hbHMiLCJmaWx0ZXJzIiwic29ydF9ieSIsInNvcnRfb3JkZXIiLCJzZWFyY2giLCJsaW1pdCIsInBhZ2UiLCJfdCIsIkRhdGUiLCJnZXRUaW1lIiwiY3JlYXRlSm91cm5hbCIsImdldEFsbEpvdXJuYWxzIiwiZ2V0Sm91cm5hbEJ5SWQiLCJnZXRBbGxSZXZpZXdlcnMiLCJhc3NpZ25SZXZpZXdlciIsImpvdXJuYWxJZCIsInJldmlld2VySWQiLCJyZXZpZXdlcl9pZCIsInJldmlld0pvdXJuYWwiLCJzdGF0dXMiLCJjb21tZW50cyIsImdldEpvdXJuYWxGaWxlIiwiZG93bmxvYWRKb3VybmFsIiwiam91cm5hbCIsImZpbGVJbmZvIiwiZG93bmxvYWRVcmwiLCJ3aW5kb3ciLCJvcGVuIiwiYSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwiZGlzcGxheSIsImFwaUJhc2VVcmwiLCJocmVmIiwiaW5jbHVkZXMiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjbGljayIsInJlbW92ZUNoaWxkIiwiZGVsZXRlSm91cm5hbCIsInVwZGF0ZUpvdXJuYWxTdGF0dXMiLCJwdWJsaXNoSm91cm5hbCIsInB1YmxpY2F0aW9uTnVtYmVyIiwicHVibGljYXRpb25fbnVtYmVyIiwidW5wdWJsaXNoSm91cm5hbCIsInJldmlld0FQSSIsImdldEpvdXJuYWxSZXZpZXdzIiwiZ2V0QXNzaWduZWRSZXZpZXdzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utils/api.ts\n"));

/***/ }),

/***/ "./src/utils/config.ts":
/*!*****************************!*\
  !*** ./src/utils/config.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBackendBaseUrl: function() { return /* binding */ getBackendBaseUrl; },\n/* harmony export */   getFrontendBaseUrl: function() { return /* binding */ getFrontendBaseUrl; },\n/* harmony export */   getPasswordResetUrl: function() { return /* binding */ getPasswordResetUrl; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n// Frontend configuration\n// Get the base URL for the frontend\nconst getFrontendBaseUrl = ()=>{\n    // In production, use the actual domain\n    if (process.env.NEXT_PUBLIC_FRONTEND_URL) {\n        return process.env.NEXT_PUBLIC_FRONTEND_URL;\n    }\n    // In development, use localhost\n    if (true) {\n        return window.location.origin;\n    }\n    // Default fallback\n    return \"https://nbu-journal.vercel.app\";\n};\n// Get the full URL for password reset\nconst getPasswordResetUrl = (email, token)=>{\n    return \"\".concat(getFrontendBaseUrl(), \"/password-reset?email=\").concat(encodeURIComponent(email), \"&token=\").concat(encodeURIComponent(token));\n};\n// Get the base URL for the backend API\nconst getBackendBaseUrl = ()=>{\n    if (true) {\n        return \"https://nbu-journal-api.onrender.com/api\";\n    }\n    // Default to the Render backend\n    return \"https://nbu-journal-backend.onrender.com/api\";\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    getFrontendBaseUrl,\n    getPasswordResetUrl,\n    getBackendBaseUrl\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMvY29uZmlnLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSx5QkFBeUI7QUFFekIsb0NBQW9DO0FBQzdCLE1BQU1BLHFCQUFxQjtJQUNoQyx1Q0FBdUM7SUFDdkMsSUFBSUMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyx3QkFBd0IsRUFBRTtRQUN4QyxPQUFPRixPQUFPQSxDQUFDQyxHQUFHLENBQUNDLHdCQUF3QjtJQUM3QztJQUVBLGdDQUFnQztJQUNoQyxJQUFJLElBQWtCLEVBQWE7UUFDakMsT0FBT0MsT0FBT0MsUUFBUSxDQUFDQyxNQUFNO0lBQy9CO0lBRUEsbUJBQW1CO0lBQ25CLE9BQU87QUFDVCxFQUFFO0FBRUYsc0NBQXNDO0FBQy9CLE1BQU1DLHNCQUFzQixDQUFDQyxPQUFlQztJQUNqRCxPQUFPLEdBQWdEQyxPQUE3Q1Ysc0JBQXFCLDBCQUEyRFUsT0FBbkNBLG1CQUFtQkYsUUFBTyxXQUFtQyxPQUExQkUsbUJBQW1CRDtBQUMvRyxFQUFFO0FBRUYsdUNBQXVDO0FBQ2hDLE1BQU1FLG9CQUFvQjtJQUMvQixJQUFJVixJQUErQixFQUFFO1FBQ25DLE9BQU9BLDBDQUErQjtJQUN4QztJQUVBLGdDQUFnQztJQUNoQyxPQUFPO0FBQ1QsRUFBRTtBQUVGLCtEQUFlO0lBQ2JEO0lBQ0FPO0lBQ0FJO0FBQ0YsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy9jb25maWcudHM/ZTg3YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGcm9udGVuZCBjb25maWd1cmF0aW9uXG5cbi8vIEdldCB0aGUgYmFzZSBVUkwgZm9yIHRoZSBmcm9udGVuZFxuZXhwb3J0IGNvbnN0IGdldEZyb250ZW5kQmFzZVVybCA9ICgpOiBzdHJpbmcgPT4ge1xuICAvLyBJbiBwcm9kdWN0aW9uLCB1c2UgdGhlIGFjdHVhbCBkb21haW5cbiAgaWYgKHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZST05URU5EX1VSTCkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GUk9OVEVORF9VUkw7XG4gIH1cbiAgXG4gIC8vIEluIGRldmVsb3BtZW50LCB1c2UgbG9jYWxob3N0XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xuICB9XG4gIFxuICAvLyBEZWZhdWx0IGZhbGxiYWNrXG4gIHJldHVybiAnaHR0cHM6Ly9uYnUtam91cm5hbC52ZXJjZWwuYXBwJztcbn07XG5cbi8vIEdldCB0aGUgZnVsbCBVUkwgZm9yIHBhc3N3b3JkIHJlc2V0XG5leHBvcnQgY29uc3QgZ2V0UGFzc3dvcmRSZXNldFVybCA9IChlbWFpbDogc3RyaW5nLCB0b2tlbjogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIGAke2dldEZyb250ZW5kQmFzZVVybCgpfS9wYXNzd29yZC1yZXNldD9lbWFpbD0ke2VuY29kZVVSSUNvbXBvbmVudChlbWFpbCl9JnRva2VuPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHRva2VuKX1gO1xufTtcblxuLy8gR2V0IHRoZSBiYXNlIFVSTCBmb3IgdGhlIGJhY2tlbmQgQVBJXG5leHBvcnQgY29uc3QgZ2V0QmFja2VuZEJhc2VVcmwgPSAoKTogc3RyaW5nID0+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTDtcbiAgfVxuICBcbiAgLy8gRGVmYXVsdCB0byB0aGUgUmVuZGVyIGJhY2tlbmRcbiAgcmV0dXJuICdodHRwczovL25idS1qb3VybmFsLWJhY2tlbmQub25yZW5kZXIuY29tL2FwaSc7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdldEZyb250ZW5kQmFzZVVybCxcbiAgZ2V0UGFzc3dvcmRSZXNldFVybCxcbiAgZ2V0QmFja2VuZEJhc2VVcmxcbn07XG4iXSwibmFtZXMiOlsiZ2V0RnJvbnRlbmRCYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0ZST05URU5EX1VSTCIsIndpbmRvdyIsImxvY2F0aW9uIiwib3JpZ2luIiwiZ2V0UGFzc3dvcmRSZXNldFVybCIsImVtYWlsIiwidG9rZW4iLCJlbmNvZGVVUklDb21wb25lbnQiLCJnZXRCYWNrZW5kQmFzZVVybCIsIk5FWFRfUFVCTElDX0FQSV9VUkwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utils/config.ts\n"));

/***/ })

});